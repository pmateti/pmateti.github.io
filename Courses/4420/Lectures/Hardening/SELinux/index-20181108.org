
# -*- mode: org -*-
#+date: 2017-09-11
#+TITLE: SELinux [WIP]
#+AUTHOR: Prabhaker Mateti
#+HTML_LINK_HOME: ../../Top/index.html
#+HTML_LINK_UP: ../
#+HTML_HEAD: <style> P,li {text-align: justify} code {color: brown;} @media screen {BODY {margin: 10%} }</style>
#+BIND: org-html-preamble-format (("en" "<a href=\"../../\"> ../../</a>"))
#+BIND: org-html-postamble-format (("en" "<hr size=1>Copyright &copy; 2017 <a href=\"http://www.wright.edu/~pmateti\">www.wright.edu/~pmateti</a> &bull; %d"))
#+STARTUP:showeverything
#+OPTIONS: toc:0

* SELinux #1

1.  By default, Unix/Linux provides Discretionary Access
   Control
   1.  The user (subject) has discretion to set security policies (or
       not)
   1.  Example: I may ‘chmod o+a’ the file containing 506
       grades, which violates university privacy policies
1.  Mandatory Access Control enforces a central policy on
   a system
   1.  Example: MAC policies can prohibit me from sharing 506
       grades
                      SELinux
1.  Like the Windows 2k ACLs, one key goal is enforcing
   the privilege of least authority
   1.  No ‘root’ user
   1.  Several administrative roles with limited extra privileges
   1.  Example: Changing passwords does not require
       administrative access to printers
       1.  The principle of least authority says you should only give
           the minimum privilege needed
   1.  Reasoning: if ‘passwd’ is compromised (e.g., due to a
       buffer overflow), we should limit the scope of the damage
                     SELinux
1.  Also like Win2k ACLs, a goal is to specify fine-grained
   access control permission to kernel objects
   1.  In service of principle of least authority
   1.  Read/write permissions are coarse
   1.  Lots of functions do more limited reads/write
           SELinux + MAC
1.  Unlike Win2k ACLs, MAC enforcement requires all
   policies to be specified by an administrator
   1.  Users cannot change these policies
1.  Multi-level security: Declassified, Secret, Top-Secret, etc.
   1.  In MLS, only a trusted declassifier can lower the secrecy
       of a file
   1.  Users with appropriate privilege can read classified files,
       but cannot output their contents to lower secrecy levels
                      Example
1.  Suppose I want to read a secret file
1.  In SELinux, I transition to a secret role to do this
   1.  This role is restricted:
       1.  Cannot write to the network
       1.  Cannot write to declassified files
   1.  Secret files cannot be read in a declassified role
1.  Idea: Policies often require applications/users to give up
   some privileges (network) for others (access to secrets)
          General principles
1.  Secrecy (Bell-LaPadula)
   1.  No read up, no write down
   1.  In secret mode, you can’t write a declassified file, or read
       top-secret data
1.  Integrity (Biba)
   1.  No write up, no read down
   1.  A declassified user can’t write garbage into a secret file
   1.  A top-secret application can’t read input/load libraries
       from an untrusted source (reduce risk of compromise)
          SELinux Policies
1.  Written by an administrator in a SELinux-specific
   language
   1.  Often written by an expert at Red Hat and installed
      wholesale
   1.  Difficult to modify or write from scratch
1.  Very expansive---covers all sorts of subjects, objects, and
   verbs
     Key Points of Interest
1.  Role-Based Access Control (RBAC)
1.  Type Enforcement
1.  Linux Security Modules (LSM)
   1.  Labeling and persistence
         Role-Based Access
                       Control
1.  Idea: Extend or restrict user rights with a role that
   captures what they are trying to do
1.  Example: I may browse the web, grade labs, and
   administer a web server
   1.  Create a role for each, with different privileges
   1.  My grader role may not have network access, except to
      blackboard
   1.  My web browsing role may not have access to my home
      directory files
   1.  My admin role and web roles can’t access students’ labs
        Roles vs. Restricted
                      Context
1.  Win2k ACLs allow a user to create processes with a
   subset of his/her privileges
1.  Roles provide the same functionality
   1.  But also allow a user to add privileges, such as
      administrative rights
1.  Roles may also have policy restrictions on who/when/
   how roles are changed
   1.  Not just anyone (or any program) can get admin privileges
      The power of RBAC
1.  Conditional access control
1.  Example: Don’t let this file go out on the internet
   1.  Create secret file role
      1.  No network access, can’t write any files except other secret
          files
      1.  Process cannot change roles, only exit
      1.  Process can read secret files
   1.  I challenge you to express this policy in Unix permissions!
   Roles vs. Specific Users
1.  Policies are hard to write
1.  Roles allow policies to be generalized
   1.  Users everywhere want similar restrictions on their
      browser
1.  Roles eliminate the need to re-tailor the policy file for
   every user
   1.  Anyone can transition to the browser role
        Type Enforcement
1.  Very much like the fine-grained ACLs we saw last time
1.  Rather than everything being a file, objects are given a
   more specific type
   1.  Type includes a set of possible actions on the object
      1.  E.g., Socket: create, listen, send, recv, close
   1.  Type includes ACLs based on roles
              Type examples
1.  Device types:
   1.  agp_device_t - AGP device (/dev/agpgart)
   1.  console_device_t - Console device (/dev/console)
   1.  mouse_device_t - Mouse (/dev/mouse)
1.  File types:
   1.  fs_t - Defaults file type
   1.  etc_aliases_t - /etc/aliases and related files
   1.  bin_t - Files in /bin
       More type examples
1.  Networking:
   1.  netif_eth0_t – Interface eth0
   1.  port_t – TCP/IP port
   1.  tcp_socket_t – TCP socket
1.  /proc types
   1.  proc_t - /proc and related files
   1.  sysctl_t - /proc/sys and related files
   1.  sysctl_fs_t - /proc/sys/fs and related files
          Detailed example
1.  ping_exec_t type associated with ping binary
1.  Policies for ping_exec_t:
   1.  Restrict who can transition into ping_t domain
      1.  Admins for sure, and init scripts
      1.  Regular users: admin can configure
   1.  ping_t domain (executing process) allowed to:
      1.  Use shared libraries
      1.  Use the network
      1.  Call ypbind (for hostname lookup in YP/NIS)
                      Ping cont.
1.  ping_t domain process can also:
   1.  Read certain files in /etc
   1.  Create Unix socket streams
   1.  Create raw ICMP sockets + send/recv on them on any interface
   1.  setuid (Why? Don’t know)
   1.  Access the terminal
   1.  Get file system attributes and search /var (mostly harmless
       operations that would pollute the logs if disallowed)
       1.   Violate least privilege to avoid modification!
                        Full ping policy
01 type ping_t, domain, privlog;
02 type ping_exec_t, file_type, sysadmfile, exec_type; 19
03 role sysadm_r types ping_t;                         20 auditallow ping_t any_socket_t:rawip_socket
04 role system_r types ping_t;                         sendto;
05                                                     21
06 # Transition into this domain when you run this     22 # Let ping receive ICMP replies.
program.                                               23 allow ping_t { self icmp_socket_t }:rawip_socket
07 domain_auto_trans(sysadm_t, ping_exec_t, ping_t)    recvfrom;
08. domain_auto_trans(initrc_t, ping_exec_t, ping_t)   24
09                                                     25 # Use capabilities.
10 uses_shlib(ping_t)                                  26 allow ping_t self:capability { net_raw setuid };
11 can_network(ping_t)                                 27
12 general_domain_access(ping_t)                       28 # Access the terminal.
13 allow ping_t { etc_t resolv_conf_t }:file { getattr 29 allow ping_t admin_tty_type:chr_file
read };                                                rw_file_perms;
14 allow ping_t self:unix_stream_socket                30 ifdef(`gnome-pty-helper.te', `allow ping_t
create_socket_perms;                                   sysadm_gph_t:fd use;')
15                                                     31 allow ping_t privfd:fd use;
16 # Let ping create raw ICMP packets.                 32
17 allow ping_t self:rawip_socket {create ioctl read   33 dontaudit ping_t fs_t:filesystem getattr;
write bind getopt setopt};                             34
18 allow ping_t any_socket_t:rawip_socket sendto;      35 # it tries to access /var/run
                                                       36 dontaudit ping_t var_t:dir search;
   Linux Security Modules
1.  Culturally, top Linux developers care about writing a
   good kernel
   1.  Not as much about security
   1.  Different specializations
1.  Their goal: Modularize security as much as humanly
   possible
   1.  Security folks write modules that you can load if you care
      about security; kernel developers don’t have to worry
      about understanding security
                    Basic deal
1.  Linux Security Modules API:
   1.  Linux developers put dozens of access control hooks all
      over the kernel
      1.  See include/linux/security.h
   1.  LSM writer can implement access control functions called
      by these hooks that enforce arbitrary policies
   1.  Linux also adds opaque “security” pointer that LSM can
      use to store security info they need in processes, inodes,
      sockets, etc.
           SELinux example
1.  A task has an associated security pointer
   1.  Stores current role
1.  An inode also has a security pointer
   1.  Stores type and policy rules
1.  Initialization hooks for both called when created
   SELinux example, cont.
1.  A task reads the inode
   1.  VFS function calls LSM hook, with inode and task pointer
   1.  LSM reads policy rules from inode
1.  Suppose the file requires a role transition for read
   1.  LSM hook modifies task’s security data to change its role
   1.  Then read allowed to proceed
        Problem: Persistence
1.  All of these security hooks are great for in memory data
   structures
   1.  E.g., VFS inodes
1.  How do you ensure the policy associated with a given
   file persists across reboots?
        Extended Attributes
1.  In addition to 9+ standard Unix attributes, associate a small
   key/value store with an on-disk inode
   1.  User can tag a file with arbitrary metadata
   1.  Key must be a string, prefixed with a domain
       1.   User, trusted, system, security
   1.  Users must use ‘user’ domain
   1.  LSM uses ‘security’ domain
1.  Only a few file systems support extended attributes
   1.  E.g., ext2/3/4; not NFS, FAT32
                   Persistence
1.  All ACLs, type information, etc. are stored in extended
   attributes for persistence
1.  Each file must be labeled for MAC enforcement
   1.  Labeling is the generic problem of assigning a type or
       security context to each object/file in the system
   1.  Can be complicated
1.  SELinux provides some tools to help, based on standard
   system file names and educated guesses
                   Summary
1.  SELinux augments Linux with a much more restrictive
   security model
   1.  MAC vs. DAC
1.  Understand Roles and Types
1.  Basic ideas of LSM
   1.  Labeling and extended attributes

* SELinux Conceptual Overview

1. Disables root and other users priviledges
   1.  Several administrative roles with limited extra privileges
   1.  Example: Changing passwords does not require root access to
       setting up firewalls

1.  Multi-Level Security: Declassified, Secret, Top-Secret, etc.
   1.  In MLS, only a trusted declassifier can lower the secrecy
       of a file
   1.  Users with appropriate privilege can read classified files,
       but cannot output their contents to lower secrecy levels
** SELinux Simple Example

1.  Suppose I want to read a secret file
1.  In SELinux, I transition to a secret role to do this.  This role
    is restricted:
       1.  Cannot write to the network
       1.  Cannot write to declassified files
   1.  Secret files cannot be read in a declassified role

** SELinux Policies
1.  Written by an administrator in a SELinux-specific
   language
   1.  Often written by an expert at Red Hat and installed
      wholesale
   1.  Difficult to modify or write from scratch
1.  Very expansive---covers all sorts of subjects, objects, and
   verbs
     Key Points of Interest
1.  Role-Based Access Control (RBAC)
1.  Type Enforcement
1.  Linux Security Modules (LSM)
   1.  Labeling and persistence
         Role-Based Access
**                       Control
1.  Idea: Extend or restrict user rights with a role that
   captures what they are trying to do
1.  Example: I may browse the web, grade labs, and
   administer a web server
   1.  Create a role for each, with different privileges
   1.  My grader role may not have network access, except to
      blackboard
   1.  My web browsing role may not have access to my home
      directory files
   1.  My admin role and web roles can’t access students’ labs
        Roles vs. Restricted
** Context
1.  Win2k ACLs allow a user to create processes with a
   subset of his/her privileges
1.  Roles provide the same functionality
   1.  But also allow a user to add privileges, such as
      administrative rights
1.  Roles may also have policy restrictions on who/when/
   how roles are changed
   1.  Not just anyone (or any program) can get admin privileges
*      The power of RBAC
1.  Conditional access control
1.  Example: Don’t let this file go out on the internet
   1.  Create secret file role
      1.  No network access, can’t write any files except other secret
          files
      1.  Process cannot change roles, only exit
      1.  Process can read secret files
   1.  I challenge you to express this policy in Unix permissions!
   Roles vs. Specific Users
1.  Policies are hard to write
1.  Roles allow policies to be generalized
   1.  Users everywhere want similar restrictions on their
      browser
1.  Roles eliminate the need to re-tailor the policy file for
   every user
   1.  Anyone can transition to the browser role
*        Type Enforcement
1.  Very much like the fine-grained ACLs we saw last time
1.  Rather than everything being a file, objects are given a
   more specific type
   1.  Type includes a set of possible actions on the object
      1.  E.g., Socket: create, listen, send, recv, close
   1.  Type includes ACLs based on roles
*              Type examples
1.  Device types:
   1.  agp_device_t - AGP device (/dev/agpgart)
   1.  console_device_t - Console device (/dev/console)
   1.  mouse_device_t - Mouse (/dev/mouse)
1.  File types:
   1.  fs_t - Defaults file type
   1.  etc_aliases_t - /etc/aliases and related files
   1.  bin_t - Files in /bin
       More type examples
1.  Networking:
   1.  netif_eth0_t – Interface eth0
   1.  port_t – TCP/IP port
   1.  tcp_socket_t – TCP socket
1.  /proc types
   1.  proc_t - /proc and related files
   1.  sysctl_t - /proc/sys and related files
   1.  sysctl_fs_t - /proc/sys/fs and related files
* Detailed example
1.  ping_exec_t type associated with ping binary
1.  Policies for ping_exec_t:
   1.  Restrict who can transition into ping_t domain
      1.  Admins for sure, and init scripts
      1.  Regular users: admin can configure
   1.  ping_t domain (executing process) allowed to:
      1.  Use shared libraries
      1.  Use the network
      1.  Call ypbind (for hostname lookup in YP/NIS)
**                      Ping cont.
1.  ping_t domain process can also:
   1.  Read certain files in /etc
   1.  Create Unix socket streams
   1.  Create raw ICMP sockets + send/recv on them on any interface
   1.  setuid (Why? Don’t know)
   1.  Access the terminal
   1.  Get file system attributes and search /var (mostly harmless
       operations that would pollute the logs if disallowed)
       1.   Violate least privilege to avoid modification!
*                        Full ping policy
01 type ping_t, domain, privlog;
02 type ping_exec_t, file_type, sysadmfile, exec_type; 19
03 role sysadm_r types ping_t;                         20 auditallow ping_t any_socket_t:rawip_socket
04 role system_r types ping_t;                         sendto;
05                                                     21
06 # Transition into this domain when you run this     22 # Let ping receive ICMP replies.
program.                                               23 allow ping_t { self icmp_socket_t }:rawip_socket
07 domain_auto_trans(sysadm_t, ping_exec_t, ping_t)    recvfrom;
08. domain_auto_trans(initrc_t, ping_exec_t, ping_t)   24
09                                                     25 # Use capabilities.
10 uses_shlib(ping_t)                                  26 allow ping_t self:capability { net_raw setuid };
11 can_network(ping_t)                                 27
12 general_domain_access(ping_t)                       28 # Access the terminal.
13 allow ping_t { etc_t resolv_conf_t }:file { getattr 29 allow ping_t admin_tty_type:chr_file
read };                                                rw_file_perms;
14 allow ping_t self:unix_stream_socket                30 ifdef(`gnome-pty-helper.te', `allow ping_t
create_socket_perms;                                   sysadm_gph_t:fd use;')
15                                                     31 allow ping_t privfd:fd use;
16 # Let ping create raw ICMP packets.                 32
17 allow ping_t self:rawip_socket {create ioctl read   33 dontaudit ping_t fs_t:filesystem getattr;
write bind getopt setopt};                             34
18 allow ping_t any_socket_t:rawip_socket sendto;      35 # it tries to access /var/run
                                                       36 dontaudit ping_t var_t:dir search;
*   Linux Security Modules
1.  Culturally, top Linux developers care about writing a
   good kernel
   1.  Not as much about security
   1.  Different specializations
1.  Their goal: Modularize security as much as humanly
   possible
   1.  Security folks write modules that you can load if you care
      about security; kernel developers don’t have to worry
      about understanding security
*                    Basic deal
1.  Linux Security Modules API:
   1.  Linux developers put dozens of access control hooks all
      over the kernel
      1.  See include/linux/security.h
   1.  LSM writer can implement access control functions called
      by these hooks that enforce arbitrary policies
   1.  Linux also adds opaque “security” pointer that LSM can
      use to store security info they need in processes, inodes,
      sockets, etc.
* SELinux Example
1.  A task has an associated security pointer
   1.  Stores current role
1.  An inode also has a security pointer
   1.  Stores type and policy rules
1.  Initialization hooks for both called when created
   SELinux example, cont.
1.  A task reads the inode
   1.  VFS function calls LSM hook, with inode and task pointer
   1.  LSM reads policy rules from inode
1.  Suppose the file requires a role transition for read
   1.  LSM hook modifies task’s security data to change its role
   1.  Then read allowed to proceed
        Problem: Persistence
1.  All of these security hooks are great for in memory data
   structures
   1.  E.g., VFS inodes
1.  How do you ensure the policy associated with a given
   file persists across reboots?
        Extended Attributes
1.  In addition to 9+ standard Unix attributes, associate a small
   key/value store with an on-disk inode
   1.  User can tag a file with arbitrary metadata
   1.  Key must be a string, prefixed with a domain
       1.   User, trusted, system, security
   1.  Users must use ‘user’ domain
   1.  LSM uses ‘security’ domain
1.  Only a few file systems support extended attributes
   1.  E.g., ext2/3/4; not NFS, FAT32
*                   Persistence
1.  All ACLs, type information, etc. are stored in extended
   attributes for persistence
1.  Each file must be labeled for MAC enforcement
   1.  Labeling is the generic problem of assigning a type or
       security context to each object/file in the system
   1.  Can be complicated
1.  SELinux provides some tools to help, based on standard
   system file names and educated guesses
*                   Summary
1.  SELinux augments Linux with a much more restrictive
   security model
   1.  MAC vs. DAC
1.  Understand Roles and Types
1.  Basic ideas of LSM
   1.  Labeling and extended attributes


** NSA Security Enhanced Linux: Further Comments

http://www.vnunet.com/News/1125743">http://www.vnunet.com/News/1125743</a>
The National Security Agency (NSA) has released its second public version of the
Security Enhanced Linux operating system. Although still in prototype, the Linux
Security Modules based OS is designed to be an almost uncrackable development of
the open source platform, which can be confidently used for "certain
sensitive or classified applications and environments".
The agency has been working on the Security Enhanced implementation since
February this year, and released the first public prototype in May. Features of
the second release include a number of bug fixes, as well as a kernel update to
the more recent 2.4.10 Linux kernel.
"This version of Linux has a strong, flexible mandatory access control
architecture incorporated into the major subsystems of the kernel. The system
provides a mechanism to enforce the separation of information based on
confidentiality and integrity requirements. This allows threats of tampering and
bypassing of application security mechanisms to be addressed, and enables the
confinement of damage that can be caused by malicious or flawed
applications."
The project was started when the NSA decided that existing mainstream
operating systems lacked the critical security feature required for enforcing
separation - mandatory access control.
"As a consequence, application security mechanisms are vulnerable to
tampering and bypass, and malicious or flawed applications can easily cause
failures in system security," the organisation said.<br clear="all">

By Liesbeth Evers, Network News <span class="bemydate">[13-06-2001]</span> The
US National Security Agency (NSA) has released a prototype version of
security-enhanced Linux, claiming it offers far stronger protection than most of
the operating systems (OSs) currently on the market.
The agency believes that popular OSs, such as Windows and Solaris, are
incapable of supporting advanced security mechanisms because security is not
in-built as part of the kernel.
Most OSs are based on discretionary security, where measures are added later,
it said. This makes it easier for intruders to circumvent measures such as
digital signatures, encryption and firewalls.
In an NSA report obtained by <i>Network News</i>, the agency warned:
"Any security effort which ignores this fact can only result in a fortress
built upon sand."
David Lindeijer, a software designer at Delft University in Holland, backed
the NSA's stance, saying that discretionary security left networks open for
abuse. The university has moved from Solaris to Windows, but found neither OS
could support firewalls well enough to prevent crackers breaking in.
At the University's Transport Labs, where Lindeijer runs a project on
internet-steered transport charts, he secured the lab's network by running it on
an OS based on Java where security is part of the kernel.
"It is stupid that mainstream OSs leave security as discretionary.
Mandatory security causes some operational problems, but they're small compared
to the damage caused by security breaks," he said.
Tim Graves, security expert and Solaris architect at Sun Microsystems, said
the company had developed Trusted Solaris with mandatory B1 security. Sun is now
considering whether to move some of its B1 security into standard Solaris.
Although more expensive to maintain, this would provide significantly better
protection.
"Banks, governments, internet service providers and web hosting
companies should run networks on secure OSs. Others should use a combination of
a mainstream OS and a B1 OS. In that way they have security at relatively low
cost," said Graves.



* References

1. https://people.redhat.com/tcameron/Summit2012/SELinux/cameron_w_120_selinux_for_mere_mortals.pdf
   200+ slides.  My lecture is based on this.  Recommended Reading.

1. http://selinuxproject.org/page/FAQ   Recommended Reading.
1. https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/pdf/selinux_users_and_administrators_guide/Red_Hat_Enterprise_Linux-7-SELinux_Users_and_Administrators_Guide-en-US.pdf
   2018 Reference
1. https://www.gurulabs.com/linux-training/courses/GL967/

1. https://people.redhat.com/~jduncan/workshops/selinux-vcu/#_apache_lab

* End
# Local variables:
# after-save-hook: org-html-export-to-html
# end:
