<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Prabhaker Mateti on Secured Distributions of Linux</title>
<style type="text/css">a:link       { color: #0000FF; text-decoration: underline }
a:visited    { color: #000080; text-decoration: underline }
a:hover      { color: blue; background-color: yellow; background-repeat: repeat; 
               background-attachment: scroll; text-decoration: underline; 
               background-position: 0% 50% }
a:active     { color: #FFFFFF; background-color: green; background-repeat: repeat; 
               background-attachment: scroll; text-decoration: underline; 
               font-weight: normal; background-position: 0% 50% }
a.c:link     { color: #000000; text-decoration: none; font-weight: normal }
a.c:visited  { color: #000000; text-decoration: none; font-weight: normal }
a.c:hover    { color: #FFFFFF; background-color: #000000; background-repeat: repeat; 
               background-attachment: scroll; text-decoration: none; 
               font-weight: normal; background-position: 0% 50% }
a.c:active   { color: #FFFFFF; background-color: #FF0000; background-repeat: repeat; 
               background-attachment: scroll; text-decoration: none; 
               font-weight: normal; background-position: 0% 50% }
</style>
<SCRIPT>
<!--
function setfocus() { document.f.q.focus(); }
// -->
</SCRIPT>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080" onload="setfocus()">

<table cellspacing="10" cellpadding="10" width="100%" border="0">
  <tbody>
    <tr>
      <td width="33%"><a target="_blank" href="http://www.wright.edu/"><img
        src="../images/wsu-logo-xsm.gif" border="0" width="150" height="66"></a><br>
        <p><br>
        <a href="http://www.cs.wright.edu/">College of Engineering &amp; CS</a><br>
        <a href="http://www.wright.edu/">Wright State University</a><br>
        <a href="http://www.dayton.net/dayton/">Dayton,</a> <a
        href="http://www.state.oh.us/">Ohio</a> 45435-0001</p>
      </td>
      <td width="67%">
        <table border="0" width="100%">
          <tr>
            <td width="100%">
              <h1>Securing a Linux Kernel</h1>
            </td>
          </tr>
          <tr>
            <td width="100%">&nbsp;</td>
          </tr>
          <tr>
            <td width="100%">
              <h2><a target="_blank" href="http://www.cs.wright.edu/~pmateti">Prabhaker
              Mateti</a></h2>
            </td>
          </tr>
          <tr>
            <td width="100%">&nbsp;</td>
          </tr>
          <tr>
            <td width="100%">We describe the issues involved in securing a&nbsp;
              Linux kernel.&nbsp; A companion article considers the security of
              entire distributions based on the Linux kernel. We describe areas
              of tightening security prior to the compilation of OS kernels
              rather than after their deployment.</td>
          </tr>
        </table>
      </td>
    </tr>
  </tbody>
</table>
<table cellspacing="0" cellpadding="0" width="100%" bgcolor="#008080" border="0">
  <tbody>
    <tr>
      <td><font color="#FFFFFF">.</font><b></b></td>
      <td align="right"></td>
    </tr>
  </tbody>
</table>
&nbsp;
<p><b>Abstract</b>:&nbsp;We describe the issues involved in securing a&nbsp;
Linux kernel.&nbsp; A companion article considers the so-called &quot;secured
distributions of Linux&quot;. We describe areas of tightening security prior to
the compilation of OS kernels rather than after their deployment.&nbsp; We do
not consider applications, not even such standard services as syslogd, kerneld
and inetd. We do consider the loading and unloading of &quot;modules&quot; (cf.
insmod&nbsp; and rmmod), and a few network configuring tools as part of the
kernel. We focus on the Linux kernel 2.4.x series.</p>
<p>We survey all known re-designs of the kernel.&nbsp; We contribute several of
our own suggestions. We conclude with an outline of how a secure kernel can be
put together incorporating all compatible security enhancements from the
standard components as distributed by the Linux kernel group.</p>
<h2><a name="Table of Contents">Table of Contents</a></h2>
<ol>
  <li><a href="#Educational Objective">Educational Objectives</a>
  <li>Terminology
    <ol>
      <li>Secure Operating Systems</li>
      <li>Trusted Operating Systems</li>
      <li>A Practical Definition of What a Linux Kernel is</li>
    </ol>
  <li>Secure Kernel Ideas
    <ol>
      <li>Capabilities</li>
      <li>Authorizations and Privileges</li>
      <li><a name="Access Control Lists">Access Control Lists</a></li>
      <li>Stack Protection</li>
      <li>Loadable Modules</li>
      <li>Source Code Audit</li>
    </ol>
  </li>
  <li>A Study of Linux 2.4 Kernels
    <ol>
      <li>Some Examples of Kernel Bugs</li>
      <li>Loadable Modules</li>
    </ol>
  </li>
  <li>Making Linux Kernel Secure
    <ol>
      <li>Careful Recompilation</li>
      <li>Kernel Audit</li>
      <li><a href="http://www.nsa.gov/selinux/">NSA Security Enhanced</a></li>
      <li>RBAC</li>
      <li>Linux Security Modules</li>
    </ol>
  </li>
  <li><a href="#Acknowledgements">Acknowledgements</a>
  <li><a href="#References">References</a></li>
</ol>
<hr>
<h2 align="left"><a name="Educational Objectives">Educational Objectives</a></h2>
<p align="left">This article is a comprehensive introduction to what is involved
in securing a&nbsp; Linux kernel.&nbsp; A companion article considers the
so-called &quot;secured distributions of Linux&quot;.&nbsp; By a distribution,
we mean a collection of system tools, applications and, of course, the
kernel.&nbsp; Securing a distribution therefore includes securing the kernel
itself.&nbsp; Securing a kernel is not only a harder topic, but also a topic of
specific interest to us and we separate the discussion of kernel per se into
this article.</p>
<p align="left">In this article, we describe areas of tightening security prior
to the compilation of OS kernels rather than after their deployment.&nbsp; We do
not consider applications, not even such standard services as syslogd, kerneld
and inetd. We do consider the loading and unloading of &quot;modules&quot; (cf.
insmod&nbsp; and rmmod), and a few network configuring tools as part of the
kernel. We focus on the Linux kernel 2.4.x series.</p>
<hr>
<h2 align="left">Terminology</h2>
<p align="left"><i>We</i> distinguish, even though it is not common yet,&nbsp;
&quot;proper configuration&quot; from&nbsp; &quot;hardening a system&quot; from
&quot;fortification&quot; from &quot;designing an OS from scratch with security
as a significant requirement&quot;.&nbsp;There are also &quot;secure operating
systems&quot; and &quot;trusted operating systems.&quot;&nbsp; Alas, no one can
offer technically rigorous definitions for these terms. For example, there is
regular Solaris and there is Trusted Solaris.&nbsp; It is also telling to find
the following quote, &quot;Windows NT is a secure operating system but only if
it's configured correctly.&quot;&nbsp; Both NT,&nbsp; and several of Unix
derivatives claim to be secure and trusted.</p>
<h3>Proper Configuration</h3>
<p>Systems as distributed are often loosely configured.&nbsp; Occasionally this
is due to sloppiness of the distributor.&nbsp; More commonly it is because the
distributor has tried to configure a generic appeal-to-all setup.&nbsp; So, it
is important that we examine the configuration at length and determine what if
any changes must be made.</p>
<p>Proper configuration of the system as given is a prerequisite to either
fortifying or hardening.&nbsp; Systems as distributed are often loosely
configured.&nbsp; Occasionally this is due to sloppiness of the
distributor.&nbsp; More commonly it is because the distributor has tried to
configure a generic appeal-to-all setup.&nbsp; So, it is important that we
examine the configuration at length and determine what if any changes must be
made.</p>
<h3>Fortification</h3>
<p>Fortification is about adding a layer of protection beyond proper
configuration of the OS and applications. This layer of protection consists of
tools that help detect changes in the system and monitor (suspicious) system
activity.&nbsp; Fortification is the addition (and in some cases <i>deletion</i>)
of packages to improve security.&nbsp; It should be done after a system has been
properly configured with the supplied components.&nbsp; Fortification frequently
will discard a supplied component in preference to a carefully chosen added
component.&nbsp;</p>
<p>Trustix is an example of a fortified Linux.&nbsp; It is based on the Red Hat
distribution, but removes certain packages, and also replaces certain packages
with &quot;more secure&quot; ones.&nbsp; The Bastille script also falls into
this fortification category.</p>
<h3>Hardening</h3>
<p>The article titled <a href="#Hardening an Operating System">&quot;Hardening
an Operating System&quot;</a> is about hardening in general, and should be read
prior to reading the present article which focuses on hardening the Linux OS. In
this article, we will be mostly concerned with hardening the Linux kernel,
version 2.4 (July 2001 approx.)</p>
<h3 align="left">Kernel v. OS v. Distribution</h3>
<p align="left">The word &quot;kernel&quot; is used variously in the OS
literature.&nbsp; In the academia, it generally refers to a nucleus.&nbsp; In
the computer industry, it refers to all the software that runs with the CPU in
the kernel mode.&nbsp; In the IT industry, it refers to everything that comes in
a shrink-wrapped box excluding such programs as shells, terminal emulators, GUI
etc.</p>
<h3 align="left">A Practical Definition of What a Linux Kernel is</h3>
<p align="left">In this article, we need a working a definition.&nbsp; Rather
than enter into a long debate trying to settle this definition, we consider the
following to be &quot;the Linux kernel.&quot;&nbsp; By kernel source we mean all
the source code that compiles and links into</p>
<ol>
  <li>the file <code>bzImage</code>, that is typically installed as <code>/boot/vmlinuz</code></li>
  <li>the files collectively known as <i>modules</i> that are typically
    installed into the directory <code>/lib/modules.</code></li>
  <li>the following system utilities: <code>insmod, rmmod, ...</code></li>
</ol>
<hr>
<h2>Secure Kernel Ideas</h2>
<p>Notes: most kernels permit hiding processes and loaded modules</p>
<h3>Fine-grained privilege</h3>
<p>On any computer system, certain operations must bypass the security
constraints normally imposed by the system. For example, in order to create a
backup, the backup operator must be able to run a backup program that is able to
read all files on the disks, even though the operator would not normally be
allowed such access. Other programs must also be carefully controlled, such as
the programs to shut down the system, create new users, and repair damaged file
systems. On a standard Unix system, there is one user ID, called the <i>root</i>,
that can bypass all security restrictions and limitations.&nbsp; On Windows
NT/2000 systems such privileged accounts are&nbsp; &quot;System&quot; and
&quot;Administrator&quot;.
<p>The inability of standard Unix to grant rights on a finer granularity is a
weakness. Also, when one process invokes another, the newly created process runs
with the user ID of the first.&nbsp; As a result, the technique of exploiting a
bug in a root program to start an interactive shell has been known for two
decades.
<p>We would like such privileges broken down into finer grained privileges.
Thus, we would like to grant the backup program the privilege to read any file,
but it must not have the privileges to shut down the system, to modify files, or
to, say, send random network packets. The use of many limited capabilities
instead of a single all-powerful mechanism is called the <i>least privilege</i>
principle.
<h3><a name="Capabilities">Capabilities</a></h3>
<p>A capability, as used in the general OS literature, is a &quot;token&quot;,
much like the identification badge that a typical employee of a company wears,
used by a process to prove that it is allowed to do an operation on an object.
The capability is a coding of both the object and the operations allowed on that
object. Intuitively, it as both an identification badge for the process, as well
as a complete list what it can do. E.g., a file descriptor obtained when opening
a file is a capability.&nbsp; Occasionally, we call such things
&quot;handles.&quot;&nbsp;</p>
<p>Operations on capabilities include copying, transferring to other processes,
modifying, and revoking a capability. A capability often has a notion of an
&quot;owner&quot; who is able to invalidate all copies and derived versions of a
capability.</p>
<p>POSIX &quot;capabilities&quot; (described in the now defunct POSIX draft
1003.1e) are quite different. These capabilities are a partitioning of the all
powerful root privilege into a set of distinct privileges.&nbsp; A process has
three sets of bitmaps called the inheritable (I), permitted (P), and effective
(E) capabilities. When a process attempts a privileged operation, system will
check the appropriate bit in the effective set of the process, instead of
checking whether the effective user id of the process is 0 as is normally done.
For example, when a process tries to set the clock, a POSIX-capability kernel
will check that the process has the CAP_SYS_TIME bit (currently bit 25) set in
its effective set.<br>
<br>
&quot;The permitted set of the process indicates the capabilities the process
can use. A process can have capabilities set in the permitted set that are not
in the effective set indicating a temporarily disabled capability. A process is
allowed to set a bit in its effective set only if it is available in the
permitted set. The distinction between effective and permitted capabilities
exists so that processes can bracket operations that need privilege.<br>
<br>
&quot;The inheritable capabilities are the capabilities of the current process
that should be inherited by a program executed by the current process. The
permitted set of a process is masked against the inheritable set during exec().
Nothing special happens during fork() or clone(). Child processes and threads
are given an exact copy of the capabilities of the parent process.</p>
<h3>Mandatory Access Control</h3>
<p>The traditional Unix limits access to files through the notions of owner,
group and the rest of the users. This model is unacceptable for higher levels of
security.&nbsp; Additional security attributes called <i>sensitivity labels</i>
(SLs) are added to system resources such as files, processes, network ports,
interfaces, and host addresses.&nbsp; Access control using system-enforced
labels is called <i>mandatory access control</i> (MAC).&nbsp;&nbsp;&nbsp;
<p>For example, incoming packets from a network interface can be assigned SLs,
perhaps based on the source IP address or the network interface. Outgoing
packets will have the label of the process or daemon that created them. An
incoming or outgoing packet will be dropped if the SL of the packet is not valid
for both the interface and the remote host.&nbsp; Network services, such as HTTP
daemons and associated CGI scripts, can be given read-only access to web pages
and CGI directories and can be completely isolated from other resources (such as
internal network interfaces, system files, and other network daemons). A network
server configured in this way can protect its web pages and CGI scripts from
ever being modified from an external connection, even if damaging bugs exist in
the software that allow incoming users to execute any random sequence of machine
instructions.&nbsp;
<h3><b>Authorizations and Privileges</b></h3>
<p><i>Authorization</i> is an attribute of a user account that enables the user
to execute a subset of&nbsp; the available programs. <i>Privileges</i> are
attributes assigned to programs that give them different grades of access to
system resources. Together, these two sets of attributes enable programs to
behave differently toward different users. Applications can be extended to
define and check new authorizations, providing a standardized protocol by which
applications and the operating platform can communicate to grant permissions to
users. Authorizations can be used to divide administrative duties into separate
roles, which can then be assigned to different users.
<h3>Independent Validation</h3>
<p>Secure kernels should undergo evaluation of their overall design,
verification of the integrity and reliability of their source code, and
systematic, independent penetration evaluation. ITSEC (Information Technology
Security Evaluation Criteria) is an internationally recognized set of standards
for the evaluation, testing, and certification of IT security products. ITSEC
certification, performed by an independent body,&nbsp; tests the claims made
about the security functionality of a product against a predetermined level of
assurance.</p>
<h3><a name="Access Control Lists">Access Control Lists</a></h3>
<p>Access Control Lists (ACLs) support fine-grained permissions. Arbitrary users
and groups can be granted or denied access in addition to the three traditional
classes of users.</DESCRIPTION>         
 POSIX 1003.1e Draft Standard 17 Access Control Lists are now part of many
commercial UNIX systems. Extended<i> </i>Attributes are arbitrary name/value
pairs that are associated with files or directories. They can be used to store
system objects (e.g., capabilities of executables, or Access Control Lists) and
user objects (e.g., the character set or mime type of a file). Access Control
Lists are implementable as extended system attributes.</p>
<p>&quot;When a system has been &quot;exploited&quot; (rooted), it's commonly
believed that complete control over the system has been achieved. This is
rarely, if ever, true (unless the running kernel has been modified, but that is
not the original problem). What has actually happened is the cracker has
elevated his or her permissions to the point where the discretionary access
protections do not prohibit anything. <b>But the access control checks are
actually still taking place.</b> It is a &quot;feature&quot; of the access
control system to allow this misuse. Access Control Lists (ACLs) make access
control much more flexible for the user to share data with particular users, but
do nothing for the security problems of the system administrator.&quot;</p>
<p><font face="Times New Roman,Times,Times NewRoman">ext2-fs ACL project</font></p>
<p>&quot;&quot;Currently, there are at least three different access control
projects that utilize the foundation set forth by the 2.4 kernel, many
cryptography projects to provide IPSec compliance and interoperability with
commercial products, and much more.</p>
<h3>Role Based Access Control</h3>
<p>Processes are assigned &quot;roles&quot; and levels of access that can be
extremely fine-grained. For example, Apache can be assigned a web-server-role
and be restricted to certain activities.&nbsp; A port, for example port 21, can
be defined as an object and then grant access to this port only to the FTP
system. Even a program running with root privileges (such as bind) would not
then be able to use port 21 as it would on an ordinary system.</p>
<p>RBAC implies large scale kernel patches, patches to system tools, etc.</p>
<h3>Security Policies and their Enforcement</h3>
<h3>Loadable Kernel Modules</h3>
<h3>Sand Boxes</h3>
<p>chroot jail</p>
<h3>Subdomains</h3>
<p>A sub domain&nbsp; specifies on a per program basis which files it can access
and how. So, e.g., a cgi script, even if hijacked by an attacker would not be
able to write to /tmp.</p>
<h3>Subjects, Objects, and Access Matrices</h3>
<h3>Domain and Type Enforcement</h3>
<p>Domain and Type Enforcement is a mandatory access control system which
assigns types to files and domains to processes. Access from domains to other
domains and from domains to types is enforced according to the DTE policy.
<p>Type enforcement&nbsp; is a partially ordered non-hierarchical labeling
system combined with access mapping from a similarly labeled execution domain.
For labeling subjects, all processes are confined to &quot;domains&quot;.
Objects (e.g. disk files) have labels known as &quot;types&quot;. And each
domain has specific permissions to do things to any particular type, say to read
files in that type. Programs can't change domains unless the system lets them.
Domain configurations are either strictly controlled or can't even be modified
in multiuser mode, depending on the implementation.</p>
<h3>Stack Protection</h3>
<h3>System Call Monitoring</h3>
<h3>Defeating TCP/IP Stack Fingerprinting</h3>
<p><a
href="http://www.usenix.org/publications/library/proceedings/sec2000/smart.html">http://www.usenix.org/publications/library/proceedings/sec2000/smart.html</a>&nbsp;</p>
Matthew Smart, G. Robert Malan, and Farnam Jahanian, <i>University of Michigan</i>
<p>&quot;This paper describes the design and implementation of a TCP/IP stack
fingerprint scrubber. The fingerprint scrubber is a new tool to restrict a
remote user's ability to determine the operating system of another host on the
network. Allowing entire subnetworks to be remotely scanned and characterized
opens up security vulnerabilities. Specifically, operating system exploits can
be efficiently run against a pre-scanned network because exploits will usually
only work against a specific operating system or software running on that
platform. The fingerprint scrubber works at both the network and transport
layers to convert ambiguous traffic from a heterogeneous group of hosts into
sanitized packets that do not reveal clues about the hosts' operating systems.
This paper evaluates the performance of a fingerprint scrubber implemented in
the FreeBSD kernel and looks at the limitations of this approach.&quot;
<h3>Source Code Audit</h3>
<h3>Formal Program Verification</h3>
<hr>
<h2 align="left">A Study of Linux 2.4 Kernels</h2>
<p align="left">This section summarizes the architecture and features of Linux
kernel series 2.4 that are relevant to security issues rather than increased
usability or performance.</p>
<h3 align="left">Some Examples of Kernel Bugs</h3>
Two security bugs found in recent (October 18, 2001) Linux kernels (2.4.x, x
&lt; 12).
<ul>
  <li>Through the use of properly constructed chains of symbolic links, a local
    attacker can lock up the kernel for long periods of time, thus creating a
    denial of service.
  <li>With the proper use of a setuid binary, the <tt>ptrace()</tt> system call
    can be fooled into tracing another setuid program, and thus into executing
    arbitrary code as root.&nbsp;This can be defeated by getting rid of the <tt>newgrp</tt>
    binary. This bug has been fixed in the 2.4.12 kernel.</li>
</ul>
<h3>Race Conditions</h3>
&quot;Temporary file race vulnerabilities occur when privi-leged programs
attempt to create temporary files in an unsafe manner. “Unsafe” means “non-atomic
with respect to an attacker’s activities.” There is no portable standard for
safely (atomically) creating temporary files, and many operating systems have no
safe temporary file creation at all. As a result, many programs continue to use
unsafe means to create temporary files, resulting in widespread vulnerabilities.
This paper presents Race-Guard: a kernel enhancement that detects attempts to
exploit temporary file race vulnerabilities, and does so with sufficient speed
and precision that the attack can be halted before it takes effect. RaceGuard
has been imple-mented, tested, and measured. We show that RaceGuard is effective
at stopping temporary file race attacks, pre-serves compatibility (no legitimate
software is broken), and preserves performance (overhead is minimal).&quot;
<h3>Domain and Type Enforcement for Linux</h3>
<p>&quot;&quot;Access control in Linux is currently very limited. This paper
details the implementation of Domain and Type Enforcement (DTE) in Linux, which
gives the system administrator a significant advantage in securing his systems.
We control access from domains to types, domain transitions, and signal access
between domains, based on a policy which is read at boot time.</p>
<p>&quot;&quot;Access control in Linux currently consists of traditional Unix
permissions and POSIX capabilities[Caps-faq]. Domain and Type Enforcement (DTE)
has been presented [DTE95,DTE96] as a useful method for enhancing access
control. DTE groups processes into domains, and files into types, and restricts
access from domains to types as well as from domains to other domains. Type
access can be any of read, write, execute, create, and directory descend. Domain
access refers the right to send signals as well as that to transition to a new
domain. A process belongs to exactly one domain at any particular time. A
process transitions to a new domain by executing a file which has been defined
as an entry point to that domain. The three types of domain transitions are
auto, exec, or none. If Domain A has auto access to domain B, and a process in
domain A executes an entry point for domain B, then the process will be
automatically switched to domain B. If domain A has exec access to domain B,
then a process running under domain A can choose whether to switch to domain B
on execution of one of B's entry points. DTE can be considered an abbreviated
form of classical capabilities[Dennis66]. In a system based upon classical
capabilities, a process carries with itself a set of access rights to particular
objects. At any point, a process can give up, or reclaim (if permitted) some of
its capabilities. POSIX capabilities work similarly, but these capabilities are
limited to a predefined subset of super user access rights such as the ability
to nice a process, boot the system or open a privileged port. In DTE, a process
carries with itself only an indicator of the domain in which it runs, and this
determines the process' access rights. A process can enter a new domain (and
hence change its access rights) only upon file execution. Trusted Information
Systems has used DTE in its proprietary firewalls, but details of its
implementation were not publicly available, and TIS appears to have stopped
using DTE altogether. A group at SAIC has recently begun a DTE for Linux
implementation [SAIC-DTE]. Jonathon Tidswell and John Potter[Tidswell97]
submitted theoretical work on extending DTE to allow safe dynamic policy
changes, but have attempted no implementation. Presented here is our prototype
implementation of DTE for Linux version 2.3.
<h3>Loadable Kernel Modules</h3>
<p>&quot;&quot;Loadable kernel modules provide an interface to hardware devices
and data within the kernel memory. Most Unix systems enforce the usage of
loadable kernel modules in order to offer maximum interaction with the
peripherals and the kernel.&nbsp; Due to those features, kernel modules have
gained the interest of intruders, since they affect the operating system at the
basic level and guarantee an efficient and hard to detect way to manipulate the
system. In the past years loadable kernel modules including backdoors have been
published for Unix systems such as Linux and FreeBSD.</p>
<a href="http://www.linuxsecurity.com/resource_files/host_security/lkm.htm">http://www.linuxsecurity.com/resource_files/host_security/lkm.htm</a>&nbsp;
<hr>
<h2>Making Linux Kernel Secure</h2>
<p>This section summarizes various contributions that make the Linux kernel more
secure.&nbsp; Note that these are separate contributions.&nbsp; To our
knowledge, there has been no attempt yet to synthesize all these into one kernel
that keeps pace with new releases of the standard kernel.</p>
<h3>Careful Recompilation</h3>
<p>Stack smashing (buffer overflow) attacks are among the most
common.&nbsp;&nbsp; By and large, these are programming errors that can be
caught by analytical techniques.&nbsp; Newer compilers are mechanizing these
techniques.&nbsp; For example, such vulnerabilities are carefully checked by the
Immunix's &quot;StackGuard&quot; enhancements to the GNU egcs compiler.&nbsp; An
entire RedHat distribution has been recompiled with this compiler resulting in
the distribution of Immunix.</p>
<h3>Libsafe 2</h3>
<p>LD_PRELOAD environment all of your users won't be able to execute anything
anymore. To fix this you have to deactivate CONFIG_GRKERNSEC_GLIBC_EXECVE.</p>
<h3>Patching a Kernel</h3>
<p>Patches are often released in binary form, but they they can also be at the
source code level.&nbsp; These replace section(s) of code in the kernel.&nbsp;
Often a patch is in response to a newly discovered security hole.&nbsp; But,
there are proactive modifications also in the open source OS. For example,
consider the following entry taken from <a href="http://www.packetstorm.com">www.packetstorm.com</a></p>
<table>
  <tr>
    <td class="fh" nowrap align="left" bgcolor="white"><nobr>File Name</nobr></td>
    <td class="fh" nowrap align="middle" width="10" bgcolor="white"><nobr>File
      Size</nobr></td>
    <td class="fh" nowrap align="middle" width="10" bgcolor="white"><nobr>Last
      Modified</nobr></td>
  </tr>
  <tr bgcolor="#cccccc">
    <td class="fl" width="56%"><a name="grsecurity-1.6-2.4.7.patch"></a><a
      class="fl"
      href="http://www.packetstormsecurity.com/UNIX/patches/grsecurity-1.6-2.4.7.patch">grsecurity-1.6-2.4.7.patch</a></td>
    <td class="fl" nowrap align="middle" width="10"><nobr>250852</nobr></td>
    <td class="fl" nowrap align="middle" width="10"><nobr>Aug 5 01:27:50 2001</nobr></td>
  </tr>
  <tr>
    <td class="fd" colspan="3">Grsecurity is a set of security patches based on
      code from hap-linux and openwall which have been ported to the 2.4.7
      kernel. It features a non-executable stack, /proc restrictions, chroot
      restrictions, linking and fifo restrictions, exec and set*id logging,
      secure file descriptors, stealth networking enhancements, signal logging,
      failed fork logging, time change logging, and more. Changes: Random IP id
      code has been completely rewritten, a bug in the linking restrictions has
      been fixed, and a new ACL system has been introduced. &nbsp;Homepage: <a
      class="fd" href="http://www.getrewted.net" target="newbrowser">http://www.getrewted.net.</a></td>
  </tr>
</table>
<p><a href="http://www.lids.org">LIDS</a> (Linux Intrsion Detection
System)&nbsp; is a series of proactive kernel patches&nbsp; [<a
href="http://www.lids.org">www.lids.org</a> , and <a
href="http://www.soaring-bird.com.cn/oss_proj/lids/">www.soaring-bird.com.cn/oss_proj/lids/</a>].&nbsp;
It provides protection from root exploits by disabling some functions that can
be used to gain unauthorized access to root. Features such as disabling the
loading of modules, locking routing tables, protecting daemons from signals,
read-only and append-only flags to protect programs or log files from a root
intruder, implementation of 'capabilities', and much more.</p>
<h3>Kernel Audit</h3>
<a href="http://www.lkap.org/mission.html">http://www.lkap.org/mission.html</a>&nbsp;
<p>not to be confused with a security audit of a system.</p>
<h3>Flask: Flux Advanced Security Kernel</NAME>
</h3>
<p><a href="http://www.cs.utah.edu/flux/fluke/html/flask.html">&nbsp;http://www.cs.utah.edu/flux/fluke/html/flask.html</a>
Flask is an operating system security architecture that provides flexible
support for security policies. The architecture was prototyped in the Fluke
research operating system. It is now being applied to the Linux operating system
(Secure Linux).</p>
<h3><a href="http://www.nsa.gov/selinux/">NSA Security Enhanced</a></h3>
<a href="http://www.vnunet.com/News/1125743">http://www.vnunet.com/News/1125743</a>
The National Security Agency (NSA) has released its second public version of the
Security Enhanced Linux operating system. Although still in prototype, the Linux
Security Modules based OS is designed to be an almost uncrackable development of
the open source platform, which can be confidently used for &quot;certain
sensitive or classified applications and environments&quot;.
<p>The agency has been working on the Security Enhanced implementation since
February this year, and released the first public prototype in May. Features of
the second release include a number of bug fixes, as well as a kernel update to
the more recent 2.4.10 Linux kernel.</p>
<p>&quot;This version of Linux has a strong, flexible mandatory access control
architecture incorporated into the major subsystems of the kernel. The system
provides a mechanism to enforce the separation of information based on
confidentiality and integrity requirements. This allows threats of tampering and
bypassing of application security mechanisms to be addressed, and enables the
confinement of damage that can be caused by malicious or flawed
applications.&quot;
<p>The project was started when the NSA decided that existing mainstream
operating systems lacked the critical security feature required for enforcing
separation - mandatory access control.
<p>&quot;As a consequence, application security mechanisms are vulnerable to
tampering and bypass, and malicious or flawed applications can easily cause
failures in system security,&quot; the organisation said.<br clear="all">
</p>
By Liesbeth Evers, Network News <span class="bemydate">[13-06-2001]</span> The
US National Security Agency (NSA) has released a prototype version of
security-enhanced Linux, claiming it offers far stronger protection than most of
the operating systems (OSs) currently on the market.
<p>The agency believes that popular OSs, such as Windows and Solaris, are
incapable of supporting advanced security mechanisms because security is not
in-built as part of the kernel.
<p>Most OSs are based on discretionary security, where measures are added later,
it said. This makes it easier for intruders to circumvent measures such as
digital signatures, encryption and firewalls.
<p>In an NSA report obtained by <i>Network News</i>, the agency warned:
&quot;Any security effort which ignores this fact can only result in a fortress
built upon sand.&quot;
<p>David Lindeijer, a software designer at Delft University in Holland, backed
the NSA's stance, saying that discretionary security left networks open for
abuse. The university has moved from Solaris to Windows, but found neither OS
could support firewalls well enough to prevent crackers breaking in.
<p>At the University's Transport Labs, where Lindeijer runs a project on
internet-steered transport charts, he secured the lab's network by running it on
an OS based on Java where security is part of the kernel.
<p>&quot;It is stupid that mainstream OSs leave security as discretionary.
Mandatory security causes some operational problems, but they're small compared
to the damage caused by security breaks,&quot; he said.
<p>Tim Graves, security expert and Solaris architect at Sun Microsystems, said
the company had developed Trusted Solaris with mandatory B1 security. Sun is now
considering whether to move some of its B1 security into standard Solaris.
<p>Although more expensive to maintain, this would provide significantly better
protection.
<p>&quot;Banks, governments, internet service providers and web hosting
companies should run networks on secure OSs. Others should use a combination of
a mainstream OS and a B1 OS. In that way they have security at relatively low
cost,&quot; said Graves.</p>
<hr>
<p align="left"><b><font face="Times New Roman,Times,Times NewRoman"
color="#000000" size="+1"><a name="VXE - Virtual eXecuting Environment">VXE -
Virtual eXecuting Environment</a></font></b>
<p><font face="Times New Roman,Times,Times NewRoman" color="#000000">One of the
main problem with UNIX security is that super user can do with system anything
he wants. There are programs (daemons) which work with super user privileges,
for example popd, sendmail, and accessible from network (Internet/Intranet).
There are bugs in many of these programs. An&nbsp; intruder connects to such
programs via network, exploits existing bugs in it and gets control over all of
the host.&nbsp;</font><font face="Times New Roman,Times,Times NewRoman">
<p>&quot;VXE creates virtual environment for each subsystem. In such environment
only needed for normal work resources are visible and available for subsystem.
Subsystem here, is startup program and all sub processes initiated (forked) by
it. Any sub process runs in the same VXE that the parent. To affect any system
resources, program use OS system calls (syscalls). VXE has means to describe
what system calls, with what parameters are available for each subsystem. For
example, it can be described (for file operation syscalls) that some files are
readable and some executable, network operations unavailable (in case of POP
server - it handle network connection, but doesn't make new ones) and this
restrictions can't be broken even by a program with super user privileges.
<p>These restrictions can be as smart as needed. If intruder gets a control over
such subsystems, he can't use ordinary methods to sniff information or affect
the system. Everything he can do in theory, using sophisticated methods, - is to
affect the work of hacked subsystem, but not OS itself, nor another subsystems.
Here, ordinary methods, are those, when intruder gets super user privileges and
runs command interpreter (shell), and ordinary utilities, such as text editor,
copy utility and so on. He can't do anything without such utilities. For
example, POP server doesn't need text editor and copy utility for it's work, so
there is no such programs in VXE environment, created for POPD protection.
<p>More exactly, VXE protects system and it's subsystems from interference of
hacked subsystem (which works under the control of VXE). And as side effect,
provides protection of subsystem itself (in a way described above). For
simplicity, in the following text, we will say that VXE protects subsystem.
<p>VXE description (VXED) is small LISP program (set of functions) which use
declarative description of acceptable parameters for different system calls.
This VXED loaded to the kernel, controls system calls parameters from the
specified subsystem. So VXEDs are dynamically loadable modules, handled by the
small LISP interpreter, inserted into the kernel. In current VXE version, this
is <b>vxelisp</b>, derived from RefLisp&nbsp; (Bill Birch <font
face="Times New Roman,Times,Times NewRoman" color="#0000ff"><u>birchb@ozemail.com.au</u></font>).
<b>vxelisp</b> has new internal bigstring representation, full set of string and
bit functions. Kernel version of <b>vxelisp</b> is reentrant, to handle
different VXEDs simultaneously.
<p>There are two methods to activate VXED. Explicit and implicit (automatic).
Explicit activation is done by <b>vxe</b> program. Parameters are VXED pathname,
path and parameters of executable, which will be run with restrictions,
described in named VXED. For automatic method, <b>vxed</b> utility preloads all
needed VXEDs into the kernel. Each VXED has activation pattern. During program
start (exec), kernel checks executable path against patterns. VXED with matching
pattern is activated. This method can be used, to activate protection at the
start of any program in specified directory (and all subdirectories). For
example, to protect system from CGI scripts, supplied by users, VXEDs can be
defined for each user subdirectory.
<p>Any sophisticated VXED can be created manually, using full power of <b>vxelisp</b>.
But VXE doesn't force administrator to learn and use LISP. One can think about
VXE as of self-learning system. VXE development system (DS) runs VXE in trace
mode.
<p>Such run makes description of permitted (used) system calls. Creation and
modification of VXED is made via WWW interface. Development system supports two
types of VXED. Strict and filesystem types. Strict VXED describes all permitted
syscalls explicitly. Filesystem VXED describes read, write, and execute
permissions for defined paths. Specified restrictions apply to filesystem
syscalls, all other syscalls are permitted. After VXED has been created for
particular subsystem, VXED works in soft mode. In this mode all violations of
VXED are logged, but syscalls are performed. VXE DS can upgrade VXED
automatically, using logged information.
<p>Surely, needed changes in VXED can be done manually using VXED editor.
Violations can be caused by intruder activity or by deviation in subsystem's
behavior under various circumstances. VXE administrator reviews log with the
help of DS and makes decision, if upgrade is reasonable. If there are no
violations, VXED can be switched to production mode. In this mode violations are
logged and syscalls are blocked (fail). Once again, the log can be used for
intruder detection or for VXED upgrade (tuning).
<p>For security reasons, all control actions over VXE can be done only by super
user and outside any VXE.
<p>VXE affects performance in following ways. If program runs outside any VXE,
every syscall executes two assembler instructions more (checks if VXE is in
effect for current process and jump if no). For every exec syscall a small C
subroutine checks if there is a matching VXED already available in the kernel.
For programs that run in VXE, a few lines of C code checks if parameter
verification is needed. Some syscalls can be marked in VXED as uncheckable (for
example, by default, read and write operations). And only the rest syscalls are
checked by very small LISP functions. These functions located in VXED and can be
easily observed by administrator.
<p>Two types of VXED are two security policy models. New models can be
implemented without any changes in the kernel. &quot;</p>
<h3>Hypervisors</h3>
<p>A hypervisor is a loadable kernel module providing a sand boxed
wrapper.&nbsp; A master kernel hypervisor coordinates installation and removal
of individual client kernel hypervisors and manages the clients. This framework
allows client kernel hypervisors to be stacked so that a variety of application
specific policies can be implemented, each by means of its own kernel hypervisor.
The hypervisors run in the kernel, but since they are loadable modules, they do
not require that the kernel be modified.</p>
<h3>LSM, Linux Security Modules</h3>
<p>Notes: include/linux/security.h</p>
<h3>Another Linux ACL project that is now defunct</h3>
<a href="http://www.tzi.de/~agbs/live/acl_eng.html">ACL for ext2</a> from the
LiVE! project of the University of Bremen, Germany.
<h3>grsecurity</h3>
grsecurity is a set of security patches for Linux 2.4 that contain all the
features of Openwall and HAP-Linux, among many other patches for 2.2, and other
OS's. It features the Openwall non-executable stack, PaX, the Oblivion ACL
system, /proc restrictions, chroot restrictions, linking and FIFO restrictions,
exec and set*id logging, secure file descriptors, trusted path execution,
randomized IP IDs, randomized PIDs, randomized TCP source ports, altered ping
ids, randomized TTL, better IP stack randomness, socket restrictions, sysctl
support on nearly all options, secure keymap loading, stealth networking
enhancements, signal logging, failed fork logging, time change logging, and
others.
<h3>Linux Trustees</h3>
<p>Linux &quot;trustees&quot; is a permission management system. It is inspired
by Novell Netware approach and Java security API. Special objects, called <i>trustees</i>,
bound to every file and directory,&nbsp; describe the permissions granted (or
denied) to certain user or group (or all except user or group), with the default
being deny. </font><font face="Times New Roman,Times,Times NewRoman">The
trustees objects are stored in the kernel memory that allows for fast
lookup.&nbsp; The permission to access a file (or directory) is calculated as
follows:</p>
<ul>
  <li>Dereference file name, replacing all symbolic links.
  <li>Set initial deny mask to empty mask, and allow mask to U, use Unix rights.
  <li>Starting from root directory check all the parents of file and file itself
    and find trustee objects applicable, and set (or clear, if C in the trustee
    mask)&nbsp; the rights in trustee mask in the permission mask applicable.
  <li>After the masks for file name is calculated:
    <ul>
      <li>If user is the super user, grant the access.
      <li>If at least one of the access modes requested is denied, deny the
        access.
      <li>If U flag is set in allow mask, and U flag is not set in deny mask,
        and the normal Linux permission code allows the access, grant access
      <li>If all the access flags requested set in allow mask, grant the access
      <li>Otherwise, deny</li>
    </ul>
  </li>
</ul>
Note, that string names (not i-node numbers) are stored in trustees object, so
the trustee system is work despite of the mount points, file system types etc.</font>
<h3>Reference Monitor for Unix Systems</h3>
<p>REMUS (REference Monitor for Unix Systems) provides a reference monitor
implemented both as a loadable kernel module and as a kernel patch.&nbsp; It can
detect illegal invocations of system calls, and also prevent loading of
malicious kernel module.&nbsp; It also integrates the Access Control Database (ACD)
with the Unix standard virtual file system <code>/proc</code>. The system
administrator sees the ACD as a directory, each file contains the set of rules
for a given critical system call.&nbsp; REMUS employs a simple mechanism for
system calls interception at the OS kernel level and requires minimal additions
to the kernel code and no change to the syntax and semantics of existing system
calls. The execution of system call is allowed only when the invoking process
and the value of the arguments comply with the rules kept in an Access Control
Database (ACD) within the kernel. Common penetration techniques that involve
tricking the system into running the intruder's own program in privileged mode
are blocked by this approach. In particular, REMUS blocks buffer overflow
attacks before they can complete.
<h3>Hypersec Kernel</h3>
<p>Hypersec is a collection of security patches applied to the standard kernel:</p>
<ol>
  <li><a href="http://www.openwall.com/linux/README">[OpenWall-1 Patch]</a></li>
  <li><a href="http://www.theaimsgroup.com/~hlein/hap-linux/">[HAP-3 Linux
    Patch]</a></li>
  <li><a href="http://www.rsbac.org/documentation.htm">[RSBAC-1.1.1 Patch]</a></li>
  <li><a href="http://linux01.gwdg.de/~alatham/ppdd.html">[PP DiskDriver-1.2]</a></li>
  <li><a href="ftp://ftp.v-lo.krakow.pl/pub/linux/patches/sec00r.desc">[Sec00r-2.2.19
    Patch]</a></li>
  <li>IPVS-1.0.6 Modules</li>
  <li><a href="http://www.vanheusden.com/Linux/kernel_patches.php3">[FP Patch]</a></li>
  <li><a href="http://www.kerneli.org/">[KernelI-2.2.19]</a></li>
  <li><a href="http://pageexec.virtualave.net/pageexec.txt">[PAX-2.2.19]</a></li>
  <li>
    <p>Raw I/O Patch</p>
  </li>
</ol>
<p>It integrates cryptography and support for encrypting loop back devices,
random PIDs and random TCP Sequence Numbers, Mandatory Access Control, Access
Control Lists, non-executable heap and stack areas, restricted /proc and /tmp,
protection against TCP OS fingerprinting.</p>
<h3>Capabilities</h3>
<p>As you know, the &quot;root&quot; user normally has complete control over all
functions of a Linux box. Binding to a privileged port, loading kernel modules,
and managing filesystems are examples of things that typically can only be done
by root. If a regular user needed to run the &quot;ping&quot; command, for
example, it was necessary to make it run with the privileges of the root user.
The ping binary needs root privileges in order to open a raw socket (an
operation managed by the kernel) to create the necessary ICMP packet for the
echo request.
<p>Another classic example is the time server, xntpd. In order to bind to the
privileged ntp port, the daemon requires root privileges. If we could somehow
simply supply the ntp daemon with root privileges for the time it takes to
manipulate the system clock as the daemon starts, then lower its privileges to
that of a normal user before processing actually starts, we can significantly
reduce the potential for a programming error from compromising the whole system.
<p>Once these privileges are relinquished, it's effectively gone until the next
reboot. Even another root process cannot regain those privileges.
<p>This is where capabilities become a critical next step in the evolution of
system and kernel security. Capabilities support extends the UNIX security model
and allows Linux to provide more fine-grained access to privileged system
commands. It is a set of &quot;rules&quot; that can be assigned to processes,
users, and files that even the root user must follow.
<p>Linux 2.2 introduced basic support, but a modification by Chris Evans to the
2.4 kernel turned capabilities into a system that is largely useable and can be
programmed into many of the common services, such as the ntp daemon. Chris'
change involved a modification to the <tt class="tt">prctl()</tt> system call
that permits a program implementing capabilities to retain its existing level of
capabilities while switching from running as root to a non-root user.
<p>Originally a <a href="http://www.guug.de/~winni/posix.1e/" target="_blank">POSIX.1e</a>
specification, now withdrawn but still a useful guide, Linux 2.4 implements nine
of the capabilities from the original draft, and an additional twenty-one that
are specific to Linux.
<p>Some of these capabilities include the ability to change file ownership, kill
processes, control kernel module management, reboot or shutdown the machine,
manipulate the system clock, and more. One can immediately see how powerful this
is -- processes that are normally set-user-id root such as /bin/ping or simply
must be run as root can now run with just the privileges they need and no more,
diminishing the likelihood of a security problem resulting in a system
compromise.
<p>Capabilities can also be controlled on a system-wide level using a
&quot;bounding set.&quot; The ability to load or unload modules might be one
such capability. The <a
href="http://www.linuxsecurity.com/feature_stories/capability.h" target="_blank">CAP_SYS_MODULE</a>
might be disabled once the system has booted and entered the normal multi-user
level to prohibit the loading or unloading of kernel modules essentially until
the next reboot. Using the lcap command, one might disable the ability to load
kernel modules using the following:
<pre>  [root@magneto /root]# lcap CAP_SYS_MODULE
</pre>
This would typically be done at the first point at which all the necessary
modules have been loaded. This is an effective countermeasure against a
malicious intruder attempting to install a backdoor kernel module. The
CAP_SYS_RAW_IO capability would also disabled to prevent hacking kernel memory
directly using /dev/kmem.
<p>A program such as xntpd might go through the following process to relinquish
the rights that are not necessary for normal operation:
<ul>
  <li>Start with full root privileges as it normally does
  <li>Bind to the privileged ntp port
  <li>Drop all capabilities other than CAP_SYS_TIME
  <li>Drop root privileges (preventing it from even writing to root-owned files)
  <li>Continue normal operation as a regular administrative account</li>
</ul>
Future changes yet to be completely implemented include the modification to
commands similar to chattr(1) to modify and tag files that will one day totally
remove the concept of a &quot;root&quot; user. The goal is to provide the
ability for a command-line tool to add or remove privileges in much the same way
we current add or remove permissions using <tt class="tt">chmod(1)</tt>.
<p>Currently, programs need to be modified to take advantage of capabilities.
With filesystem capabilities, this sometimes won't be necessary. It might go
something like this:
<pre>  [root@magneto /root]# chattr +CAP_BIND xntpd
</pre>
This would enable the xntpd process to bind to a socket without requiring root
privileges prior to being run. Quite powerful. At the same time, it's also
contains a certain potential danger due to making an unprivileged binary
slightly privileged.
<p>&nbsp;</p>
<h3>Open Source Cryptography</h3>
<p>Encryption is the key to the next generation of Internet communications. No
longer is it possible to use the protocols that were commonplace in times before
electronic commerce, companies relying on their Internet presence for
interacting with customers, and even basing their corporate image on it.
<p>Changes in the crypto export regulations in October of 2000 now make it
possible to not only distribute open source cryptography from a web site freely,
but also object code derived from open source software. The origin location of
the source code must send a message to the Bureau of Export Administration <a
href="http://www.bxa.doc.gov/Encryption/PubAvailEncSourceCodeNofify.html"
target="_blank">indicating their intent</a>.
<p>The kernel.org web site now has a <a
href="ftp://ftp.kernel.org/pub/linux/kernel/crypto/v2.4/" target="_blank">cryptography
repository</a>, and contains crypto extensions to the new 2.4 kernel that
provide the ability to encrypt filesystems, create virtual private networks, and
more.
<p>I had an opportunity to speak with Alexander Kjeldaas, the lead developer for
the kernel crypto work, and asked him about the state of support of crypto in
the 2.4 kernel.
<p>&nbsp;
<div class="quote">
  &quot;Lots of ciphers are supported -- the ones most currently used such as <a
  href="http://www.counterpane.com/blowfish.html" target="_blank">Blowfish</a>, <a
  href="http://www.ssh.fi/tech/crypto/algorithms.html#asymmetric"
  target="_blank">IDEA</a>, <a
  href="http://www.cl.cam.ac.uk/~rja14/serpent.html" target="_blank">Serpent</a>,
  <a href="http://www.linuxsecurity.com/feature_stories/interview-aes.html"
  target="_blank">AES</a>, 3DES, DES and others. Some digest algorithms are also
  supported - MD5 and SHA1. No hardware acceleration is supported yet. The API
  is mostly synchronous the way most crypto APIs are designed, but when we start
  getting hardware acceleration this might change and we might get an
  asynchronous interface -- developing this interface will probably be done with
  an eye on the IPSec needs. Only symmetric ciphers are supported -- no
  asymmetric stuff (RSA, etc.) is supported or planned.&quot;
  <p>&nbsp;</p>
</div>
Quite a number of improvements have been made since the crypto that was
developed for the 2.2 kernel. Alexander writes, &quot;Previously cipher modules
could be looked up by number or by name. This was to be compatible with the old
/dev/loop interface that requested &quot;transforms&quot; by number. In 2.4, the
numbering scheme is removed which means that users no longer have to include a
lot of entries into /etc/modules.conf to use encrypted block devices. It also
means that other developers that wants to create their own module for various
projects don't have to allocate global &quot;IDs&quot; for their modules.&quot;
Alexander continues by stating that he is confident that crypto will be
integrated into the kernel, but feels there are some further code changes that
need to be made before this can be done. Once these final code changes are
complete, the group will push further for inclusion in the mainline kernel tree.
<p>He also gave me some insight into what changes we can look forward to with
regard to security and Linux in the future.
<div class="ulquote">
  <ul>
    <li>Encrypted swap based on /dev/loop will hopefully be work during 2.4.
      Swapping is a bit tricky since you can't allocate memory during write-out.
      In time, we might want to have a notion of an encrypted device that is
      controlled by a table of keys instead of a single key. One key would
      control a segment of the device and the individual keys could be
      exchangeable. This is especially useful for implementing encrypted swap.
      By having a table of keys, the swap code can &quot;erase&quot; a section
      of the swap-device as soon as this section becomes unused by changing a
      key in the key-table. This improves the security of encrypted swap for
      long-running servers.
      <p>&nbsp;</p>
    <li>Getting the patch integrated (with the kernel and distributions).</li>
  </ul>
</div>
Other crypto-related stuff to look forward to:
<div class="ulquote">
  <ul>
    <li>IPSec being integrated in distributions
      <p>&nbsp;</p>
    <li>I am a big fan of type enforcement, so I really look forward to seeing
      something like the NSA-sponsored work getting integrated. I hope the Linux
      community sees the need for these kinds of security frameworks.
      <p>&nbsp;</p>
    <li>I also really like <a href="http://www.mcdonald.org.uk/StegFS/"
      target="_blank">StegFS</a>.</li>
  </ul>
</div>
<div class="heading">
  <h3>Kernel Devices and Configuration Options:</h3>
</div>
<!------------------------------------------------->
<p>The 2.4 kernel includes a few block and character devices available on Linux
that will also help you with security. Although not necessarily new in the new
2.4 kernel, they are relatively unknown but extremely powerful.
<p>These devices, <tt class="tt">/dev/random</tt> and <tt class="tt">/dev/urandom</tt>,
are managed by the kernel and provide random data at any time for any number of
applications. This might include generating random passwords, seeding TCP
sequence numbers, and even cryptographic functions.
<p>Both <tt class="tt">/dev/random</tt> and <tt class="tt">/dev/urandom</tt>
should be secure enough to use in generating PGP keys, SSH challenges, and other
applications where secure random numbers are requisite. Attackers should be
unable to predict the next number given any initial sequence of numbers from
these sources. There has been a lot of effort put in to ensuring that the
numbers you get from these sources are random in every sense of the word random.
<p>The only difference is that <tt class="tt">/dev/random</tt> runs out of
random bytes and it makes you wait for more to be accumulated. Note that on some
systems, it can block for a long time waiting for new user-generated entry to be
entered into the system. So you have to use care before using <tt class="tt">/dev/random</tt>.
<p><tt class="tt">/dev/random</tt> is high quality entropy, generated from
measuring the system interrupt times and other events which are
non-deterministic. It blocks until enough bits of random data are available.
<p><tt class="tt">/dev/urandom</tt> is similar, but when the store of entropy is
running low, it'll return a cryptographically strong hash of what there is. This
isn't as secure, but it's enough for most applications.
<p>You might read from the devices using something like:
<pre>  [dave@magneto ~dave]# head -c 6 /dev/urandom | mmencode
</pre>
This will print (approximately) six random characters on the console, suitable
for password generation. You can find <tt class="TT">mmencode(1)</tt> (perhaps
also known as mimencode on some systems) in the metamail mail package.
<p>See <a href="http://www.linuxsecurity.com/feature_stories/random.c"
target="_blank">/usr/src/linux/drivers/char/random.c</a> for a description of
the algorithm.</p>
<p>&nbsp;</p>
<hr>
<h2><a name="Acknowledgements">Acknowledgements</a></h2>
<p>The above serves as a quick introduction to the many Linux distributions that
claim to be secure.&nbsp; We intend to turn this document into a properly
written technical report in the next few weeks.</p>
<p>Notes: include/linux/security.h</p>
<hr>
<h2><a name="References">References</a></h2>
<p>TBD: List these alphabetically.</p>
<ol>
  <li>ITSEC</li>
  <li><a href="mailto:bkproffitt@home.com">Brian Proffitt</a>, DistributionWatch
    Review: SmoothWall Linux 0.9.4: A Secure Distribution, <a
    href="http://www.linuxplanet.com/linuxplanet/reviews/2341/1/">http:// www.
    linuxplanet.com/ linuxplanet/ reviews/ 2341/ 1/</a>, March 30, 2001.</li>
  <li>Marcel GagnÈ,<em> </em>The e-smith server and gateway,&nbsp; 12-June-2001
  <li>LKAP: A Manifesto for a Secure Linux Kernel Audit, <a
    href="http://mail.nl.linux.org/kernel-audit/">http://mail.nl.linux.org/kernel-audit/</a>,
    <a href="http://www.lkap.org/mission.html">http://www.lkap.org/mission.html</a>
    &nbsp;</li>
  <li>List of Linux Distributions, <a
    href="http://kernelnotes.org/dist-index.html">http://kernelnotes.org/dist-index.html</a>&nbsp;</li>
  <li>Linux Firewall and Security Site, <a
    href="http://www.linux-firewall-tools.com/linux/">http://www.linux-firewall-tools.com/linux/</a>&nbsp;</li>
  <li>The linux-security-module Archives, <a
    href="http://mail.wirex.com/pipermail/linux-security-module/">http://mail.wirex.com/pipermail/linux-security-module/</a>&nbsp;</li>
  <li><font color="#000000">VXE - Virtual eXecuting Environment, <a
    href="http://www.intes.odessa.ua/vxe/">http://www.intes.odessa.ua/vxe/</a>&nbsp;</font></li>
  <li>Bastille-Linux Scripts to Secure Linux, <a
    href="http://www.sans.org/newlook/projects/bastille_linux.htm">http://www.sans.org/newlook/projects/bastille_linux.htm</a>
    &nbsp;
  <li>Se·n Boran, Hardening Solaris, October 25, 1999, <a
    href="http://securityportal.com/cover/coverstory19991025.html">http://securityportal.com/cover/
    coverstory19991025.html</a>&nbsp; .
  <li>Michael Espinala, &quot;The Hardening of Microsoft Windows NT Operating
    System Version 4.0&quot;, March 1998.&nbsp; Proper configuration,
    actually.&nbsp;</li>
  <li>Se·n Boran, Hardening Solaris, October 25, 1999, <a
    href="http://securityportal.com/cover/coverstory19991025.html">http://securityportal.com/cover/
    coverstory19991025.html</a>&nbsp; Reference.</li>
  <li>Crispin Cowan, Steve Beattie, Chris Wright, and Greg Kroah-Hartman,
    RaceGuard: Kernel Protection From Temporary File Race Vulnerabilities, 10th
    USENIX Security Symposium, August 13ñ17, 2001.</li>
  <li>Andreas Gr¸nbacher, Extended Attributes and Access Control Lists for
    Linux, <a href="http://acl.bestbits.at/">http://acl.bestbits.at/</a>, 28
    October 2001</li>
  <li>Xie Huagang and Nick DeClario, Build a Secure System with LIDS, <a
    href="http://www.linuxsecurity.com/feature_stories/feature_story-12.html">http://www.
    linuxsecurity. com/ feature_stories/ feature_story-12.html</a>, May 2000.</li>
  <li>Mike Frantzen, Cerias, and Mike Shuey, &quot;StackGhost: Hardware
    Facilitated Stack Protection,&quot; 10th USENIX Security Symposium, August
    13ñ17, 2001.</li>
  <li>Capabilities FAQ, <a
    href="ftp://ftp.guardian.no/pub/free/linux/capabilities/capfaq.txt">ftp://ftp.guardian.no/pub/free/linux/capabilities/capfaq.txt</a></li>
  <li>Immunix OS<b> </b><a href="http://www.wirex.com/">http://www.wirex.com/</a>&nbsp;
    http://<a href="http://immunix.org">immunix.org</a>.&nbsp; Carefully
    re-compiled RedHat distribution.&nbsp;</li>
  <li>Janus, <a href="http://www.cs.berkeley.edu/~daw/janus/">http://www.cs.berkeley.edu/~daw/janus/</a>
    Janus is a security tool for sandboxing untrusted applications within a
    restricted execution environment. This can be used to limit the harm that
    can be caused by any successful compromise of the application. We have
    successfully used Janus to jail Apache, bind, and other programs within a
    limited sandbox without disturbing application behavior, and we continue to
    seek experience with using this approach in production environments.</li>
  <li>Prabhaker Mateti, Configuring a System Properly, Lecture Notes on Internet
    Security, July 2001,&nbsp; <a
    href="http://www.cs.wright.edu/~pmateti/Courses/429/Config/index.html">http://www.cs.wright.edu/
    ~pmateti/ Courses/ 429/ Config/ index.html</a></li>
  <li>Prabhaker Mateti, Configuring a System Properly, <a
    href="http://www.cs.wright.edu/~pmateti/Courses/429/Config/index.html">http://www.cs.wright.edu/~pmateti/Courses/429/Config/index.html</a>,
    Wright State University, Spring 2001</li>
  <li>Prabhaker Mateti, Security Fortification, <a
    href="http://www.cs.wright.edu/~pmateti/Courses/429/Fortification/index.html">http://www.cs.wright.edu/~pmateti/Courses/429/Fortification/index.html</a>,&nbsp;
    Wright State University, Spring 2001</li>
  <li>Prabhaker Mateti, Secured Distributions of Linux, working draft,&nbsp;
    Wright State University, October 2001.</li>
  <li>Prabhaker Mateti, <a name="Hardening an Operating System">Hardening an
    Operating System</a>, Lecture Notes on Internet Security, July 2001, Wright
    State University. <a
    href="http://www.cs.wright.edu/~pmateti/Courses/429/HardenOS/index.html">http://www.cs.wright.edu/~pmateti/Courses/429/HardenOS/index.html</a>
    Required Reading.</li>
  <li>Jon Lasser,, and Jay Beale, Bastille-Linux Scripts to Secure Linux, <a
    href="http://www.sans.org/newlook/projects/bastille_linux.htm">http://www.sans.org/newlook/projects/bastille_linux.htm</a>,
    June 2001.</li>
  <li>Terrence Mitchem, Raymond Lu and Richard O'Brien, &quot;Kernel Hypervisors,
    Using Kernel Hypervisors to Secure Applications,&quot; Annual Computer
    Security Application Conference (ACSAC 97),&nbsp; December 1997, <a
    href="http://www.securecomputing.com/khyper/">http://www.securecomputing.com/khyper/</a></li>
  <li>NSA, SE Linux <a href="http://www.nsa.gov/selinux/">http://www.nsa.gov/selinux/</a></li>
  <li>REMUS Project: REference Monitor for Unix Systems, <a
    href="http://twiki.dsi.uniroma1.it/twiki/view/Remus/WebHome">http://twiki.dsi.uniroma1.it/twiki/view/Remus/WebHome</a></li>
  <li>R. Spencer, S. Smalley, P. Loscocco, M. Hibler, D. Andersen, and J.
    Lepreau, &quot;The Flask Security Architecture: System Support for Diverse
    Security Policies,&quot;&nbsp; <em>Proceedings of the Eighth USENIX Security
    Symposium</em>, pp. 123-139, Aug. 1999.</li>
  <li><a href="mailto:zavadsky@bigfoot.com">Vyacheslav Zavadsky</a>, Linux
    Trustees, <a href="http://trustees.sourceforge.net/">http://trustees.sourceforge.net/</a></li>
  <li>Andrew G. Morgan, Linux-Privs,&nbsp; <a
    href="http://www.linuxsecurity.com/resource_files/server_security/linux-privs/linux-privs.html"
    target="_blank">http://www.linuxsecurity.com/resource_files/server_security/linux-privs/
    linux-privs.html</a></li>
  <li>LCAP - Linux Kernel Capability Bounding Set Editor, <a
    href="http://pweb.netcom.com/~spoon/lcap/" target="_blank">http://pweb.netcom.com/~spoon/lcap/</a></li>
  <li>Pragmatic, &quot;(nearly) Complete Linux Loadable Kernel Modules: The
    definitive guide for hackers, virus coders and system administrators,&quot; <a
    href="http://www.thehackerschoice.com/papers/LKM_HACKING.html">http://www.thehackerschoice.com/papers/LKM_HACKING.html</a>,
    March 1999.</li>
  <li>David Larochelle and David Evans. <a
    href="http://www.cs.virginia.edu/~evans/usenix01-abstract.html"><em>Statically
    Detecting Likely Buffer Overflow Vulnerabilities</em></a>. In <a
    href="http://www.usenix.org/events/sec01/" <em>2001 USENIX Security
    Symposium</a>, Washington, D. C., August 13-17, 2001. (<a
    href="http://lclint.cs.virginia.edu/usenix01.pdf">PDF</a>, <a
    href="http://lclint.cs.virginia.edu/usenix01.html">HTML</a>, 13 pages)</li>
  <li>Matthew Smart, G. Robert Malan, and Farnam Jahanian, University of
    Michigan, &quot;Defeating TCP/IP Stack Fingerprinting,&quot; August 2000, <a
    href="http://www.usenix.org/publications/library/proceedings/sec2000/smart.html">http://www.usenix.org/publications/library/proceedings/sec2000/smart.html</a>.</li>
  <li>Antony Edwards, Trent R. Jaeger, Xiaolan Zhang, &quot;Verifying
    Authorization Hook Placement for the Linux<br>
    Security Modules Framework, IBM Tech Report RC22254 November 2001.</li>
</ol>
<div align="right">
  <table cellspacing="0" cellpadding="0" width="100%" bgcolor="#008080"
  border="0">
    <tbody>
      <tr>
        <td align="right">&nbsp;</td>
      </tr>
    </tbody>
  </table>
</div>
<table cellspacing="0" cellpadding="0" width="100%" border="0">
  <tbody>
    <tr>
      <td width="71%"> <a
        href="file:///X:/Security/copyright.html">Copyright ©</a> 2004 <a
        href="mailto:pmateti@cs.wright.edu?subject=CEG429/IntnetSecurity">pmateti@cs.wright.edu</a></td>
      <td align="right" width="29%"><!--webbot bot="Timestamp" startspan
        s-type="EDITED" s-format="%m/%d/%y %I:%M:%S %p" -->01/26/02 12:30:41 PM<!--webbot
        bot="Timestamp" i-checksum="27137" endspan --></td>
    </tr>
  </tbody>
</table>

</body>
