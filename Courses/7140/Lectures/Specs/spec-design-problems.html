<html>

<head>
<title>Software Engineering by Mateti</title>
<base target="_self">
<base target="_top">
<style type="text/css">
  a:hover      { color: blue; background-color: yellow; }
  a:active     { color: white; background-color: green;}
  p { text-align: justify }
  li {text-align: justify;}
  pre {border:blue 1px dotted;}
  tt {border:blue 1px dotted;}
  @page { size: 8.5in 11in }
  @media screen {BODY {margin: 12%;} }
  body {counter-reset: chapter; counter-reset: section;}
  h2:before {content: counter(section) ". "; counter-increment: section;}
</style>
</head>

<body>

<h1>Software Engineering Exercises in the Small</h1>

TBD htmlize from LaTeX


<h2>Several Tiny Examples</h2>

<p>
Write <i>functional specifications</i> for the following informally
expressed functions.  Remember that the weaker the preconditions, the
better the spec is.  You can use any of the "well-known" functions.
To keep this handout compact, I have dropped the phrase "A function
that yields the ..."  from the beginning of each problem statement.

<ol>

<li>
second smallest number from the given set of integers.

<li>
number of 1's in the binary representation of the given natural
number.

<li>
set of all prime factors of a given natural number.
Examples: 12 mapsto {2, 3}; 256 mapsto {2}.

<li>
sorted sequence from a given pair of sequences of integers that may
or may not be sorted.

<li>
reverse of the given sequence of characters.  For example, given 
"abdbc" return "cbdba".

<li>
true iff the two sequences of characters are a permutation of each
other.  Some characters may appear more than once.

<li>
pruned sequence of words, each of which contains at least three
different vowels, from the given sequence of words.

<li>
pruned sequence of words that have a prefix (i.e., initial substring)
matching the given word.  A dictionary of words is global.

<li>
tab-free sequence s of lines from a given sequence t of lines that may
contain tabs.  Both s and t "look the same when printed".  Assume that
tab positions are set at every multiple of 8.

<li>
number of white-space "rivers" in a given text file.  Assume that the
file does not contain tabs.  When a text file is printed, rivers are
seen as 2-dimensional connected chains of white spaces.
</ol>

<h2>Mark Errors</h2>

In processing an input line of text, a program we are working on
discovers errors.  Each error is recorded as a pair $(p, e)$ of
numbers.  We wish to point to the $p$-th character that caused the
error, and print the error number $e$ next to it.  Some times a single
position in the input line triggers multiple errors.  You are given a
list of these pairs, and the input line.  We need a procedure that
prints this line, and the error numbers below it, properly located.
Use no more lines than necessary.


<h3>Example 1</h3>
<pre>
error list     : (4,1), (7,2), (10, 2), (20, 2), (23, 2).
column numbers :|1234567890123456789012345|
line of text   :| Thos broplem is peenuds.|
line of errors :|   ^1 ^2 ^2        ^2 ^2|
</pre>

<h3>Example 2</h3>
<pre>
error list     : (5, 9), (13, 9), (13, 787), (18,94), (18, 126), (25,73),
(continued)    : (30, 9), (30, 23), (30, 26), (39, 9), (40, 742).
column numbers :|12345678901234567890123456789012345678901234|
line of text   :| if x > 0 anf y +) then 0 := x else f(x.y) ;|
line of errors :|    ^9      ^9   ^94,126^73  ^9,23,26 ^9|
line of errors :|            ^787                       ^742|
\end{tabbing}
</pre>




<h2>Condense a List of Numbers</h2>

{\sl You are given a comma separated list of items in a text file.
The list is terminated with a period.  Each item is either a number,
or a hyphen separated pair of numbers.  Your program should condense
this list as much as possible, as can be seen from the following
examples.}

{\tt
1,3,4,2,6,5,8,5,7. {\rm becomes}
1-8.

9,100-4870,4993,4871-4875,5016,5118,7-250,5100-5123. {\rm becomes}
7-4875,4993,5016,5100-5123.

1103,1023-1100,87654321,1050-1150,1110,1250-1344. {\rm becomes}
1023-1150,1250-1344,87654321.
}

<h2>Simple Simultaneous Substitutions</h2>

<p>
This program should work like a Unix filter.  It should translate a
sequence of bytes input to it by replacing certain input bytes $b_i$
by a byte sequence $s_i$.  The replacements required are given in a
binary file as a set of ordered pairs $(b_i, s_i)$; it is possible
that some $s_j$ are empty sequences.  {\sl You design the detailed
format of this binary file.} This program is intended to run on a
rather primitive machine with a severe shortage of memory.  The io
operations available are also primitive.  The open/close operations
are similar to those of Unix, but the read/write primitives can
read/write only sequences of bytes exactly 512-bytes long.
<p>
{\tt int open(const char *filename, char readwritemode)}.  The mode char is
\verb|'r'| for reading \verb|'w'| for writing.  It returns a filehandle.

<p>{\tt int close(int filehandle)}.

<p>{\tt int readblock(int filehandle, char * buffer)} will read the next
512 bytes (if available) into {\tt buffer[]}.  If fewer than 512 bytes
are available, the {\tt readblock} will pad the buffer with {\sc ascii
nul} characters.  It returns the actual number of bytes read.
<p>
{\tt int writeblock(int filehandle, char * buffer)} will write {\sl the}
512-bytes given in {\tt buffer[]}.
</li>
</ol>

<h2>Game of Solitaire</h2>


<hr size="1">
<a href="http://www.cs.wright.edu/~pmateti/copyright.html">
Copyright</a> &copy; 2013 
<a target="_blank" href="http://www.cs.wright.edu/~pmateti">
  Prabhaker Mateti</a>


</body>
</html>
