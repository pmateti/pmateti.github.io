<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Worms -- OOP Redo: worms-doc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<style type="text/css">
  body {margin: 10% 10% 10% 10%;}
  a:hover      { color: blue; background-color: yellow; }
  a:active     { color: white; background-color: green;}
  @page { size: 8.5in 11in }
  P { text-align: justify }
  @media screen {BODY {margin: 10%} }
  td {border: 1px dotted lightgray;}
</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Worms -- OOP Redo
   </div>
   <div id="projectbrief">Worms-Redo Project as a learning vehicle.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<div class="contents">
<div class="textblock"><h1>Worms Documentation</h1>
<p>This file was a "notes to myself" that I edited a bit for use by others. It is about <a href="./worms-one-file.cpp.html">worms.cpp</a>, a solution to a problem in CS1 courses. Like all documentations of real programs, the source code may have been updated without a corresponding update here. </p>
<ol>
<li>
<p class="startli">We are using the word worm as in an earth worm. Our worms travel on a rectangular (x,y)-grid plane. They are born with their head positioned just below this plane (i.e., their body hangs on z-axis vertically down). We have three kinds of worms: vegetarian (eat only carrots), cannibal (eat everything), scissorhead (cut the others).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a href="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/">http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/</a></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Is this file at the level expected of CS1? Well, not quite. There are several items in the code that I implemented in a particular way so as to be able to pedagogically show style and technique, and raise some questions. </p><ol>
<li>
srand time <a class="el" href="worm_8hpp.html#a970311ee5504bf0e1c421be1bbd78d39">random()</a>; </li>
<li>
code formatting; </li>
<li>
<p class="startli"><code> nworms = nVegetarians = nCannibals = nScissors = 0;</code> Such multiple assignments are very suitable in initializations.</p>
<p class="endli"></p>
</li>
<li>
the comma "," operator; </li>
<li>
the conditional "?" expression </li>
<li>
the "hjkhkjhkjh" is a const char [] </li>
<li>
Use unsigned whenever possible </li>
<li>
isValid(wp) is the same as wp != 0? </li>
<li>
Would the following improve any thing? <code> typedef struct { int row, col; } POSITION; </code> </li>
<li>
Consider all the names used in this program. Does the underscore feel ok? Should showWormsAndCarrots be show_Worms_And_Carrots? Should we use a mix of lower and upper case? Should digits be allowed within instead of only at the end of a name? What names will you change? Why? </li>
</ol>
<p class="endli"></p>
</li>
<li>
<pre>
typedef signed char COORD; /* coordinate type */
/* dx/dy changes, indexed by DIRECTION */
COORD dxa[] = {+0, +1, +1, +1, +0, -1, -1, -1};
COORD dya[] = {-1, -1, +0, +1, +1, +1, +0, -1};
</pre> </li>
<li>
<p class="startli">So COORD is an integer in the range -128..127. Plus-zero in the above could be written without the sign. I added the + just to line up the values.</p>
<p class="endli"></p>
</li>
<li>
<pre>
typedef struct {
  LIFE status;
  WORM_KIND type;
  DIRECTION direction;   /* its (head's) direction */
  unsigned char nsegs;   /* actual # of segs in this worm */
  SEGMENT body[MAXsegs]; /* body parts */
  unsigned int stomach;
} WORM;
</pre> </li>
<li>
<p class="startli">nsegs is guaranteed to be no more than MAXsegs. Suppose MAXsegs == 64; so, 8-bits of an unsigned char will do.</p>
<p><code> unsigned int stomach;</code></p>
<p>is at the end just to show that an array field does not have to be the last of a struct. However, it <em>is</em> useful to have an array that needs to be of varying length at the end. You will see this in more advance programming.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p><code>int nworms; /* high water mark of the worm[] */</code></p>
<p class="endli"></p>
</li>
<li>
<p class="startli">0 &lt;= nowrms &lt;= MAXworms, always. The only place it gets incremented is in <a class="el" href="worm_8hpp.html#abedae467ca2f74b4340e946f7c792067">findSlot()</a>. Gets initialized in </p><pre class="fragment">nworms = nVegetarians = nCannibals = nScissors = 0;
</pre><p>of main(). Never gets decremented. Why??</p>
<p class="endli"></p>
</li>
<li>
<pre>
int xworms[3];             /* counts of different worms */
#define nVegetarians    *xworms
#define nCannibals  *(xworms + 1)
#define nScissors   *(xworms + 2)
#define nAllWorms   (nVegetarians + nCannibals + nScissors)
#define incWorms(t) *(xworms+t) += 1
#define decWorms(t) *(xworms+t) -= 1
</pre><p class="endli"></p>
</li>
<li>
<p class="startli">This illustrates a good use of macros. xworms[] is an array so that we could increment/decrement using the worm-type as an index. nCannibals etc #defines retain the readability.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Note that <code>*(xworms+t)++</code> is not the same as *(xworms+t) += 1. To understand this, consider *p++.</p>
<p class="endli"></p>
</li>
<li>
<pre>
typedef struct {       /* A Square On the Ground */
 char onec;        /* one character */
 char attr;        /* its color */
} ASOG ;</pre>
<pre>
  ASOG  passive[MAXrow * MAXcol];          /* for Carrots and Dead Worms */
ASOG  screenImage[MAXrow * MAXcol];  /* what gets displayed */
#define <a class="el" href="worm_8hpp.html#ac9f824eaa8436e902f71af9b278f6b91">asog(ptr, row, col)</a> (ptr + (row - 1)*screenCols + col - 1)
</pre> <p>These two (passive and screenImage) together is what you see on the monitor. Note that they are 1-D arrays. The macro takes what in 2-D-array-index notation would be a[i][j] and turns it into a 1-D ptr-based left-value.</p>
<p></p>
<p>Why -1? Because, the screen coordinates start from 1 not 0, but C array indices begin at 0.</p>
<p></p>
<p>Why are we not multiplying with MAXcol in <code> #define <a class="el" href="worm_8hpp.html#ac9f824eaa8436e902f71af9b278f6b91">asog(ptr, row, col)</a> (ptr + (row - 1)*screenCols + col - 1) </code></p>
<p>Because, even though we declared the two 1-D arrays passive and screenImage to be sufficiently long to be considered MAXrow-by-MAXcol 2-D arrays, we actually are using them as screenRows-by-screenCols arrays.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We display the carrots and worms by first copying the entire passive[] into screenImage[]. Then we draw the images of the live worms onto screenImage[]. We then blast the entire array screenImage to the monitor screen via the puttext().</p>
<p class="endli"></p>
</li>
<li>
<pre>
void drawAWorm(WORM * wp)
{
  if (wp-&gt;status != EATEN) {
    ASOG  *f = (wp-&gt;status == ALIVE ? screenImage : passive);
    SEGMENT *bp, *lp = lastSeg(wp);
    for (bp = wp-&gt;body + 1; bp &lt;= lp; bp++)
      drawSegment(wp, bp, f);
  }
}
</pre><p> Even in plain C, you <em>can</em> declare at the beginning of <em>every</em> brace.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">By now, you have gotten used to conditional expressions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">But, why are we skipping the eraser-blank? Should that be drawn also. Why isn't the worm leaving its droppings behind?</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">A number of routines have <code>pre: wp != NULL</code>. Why? Because, we almost immediately do wp-&gt;... which crashes otherwise.</p>
<p class="endli"></p>
</li>
<li>
<pre>
int isHungry(WORM * wp)
{
  int m = wp-&gt;stomach;
  int n = wp-&gt;nsegs * worm_info[wp-&gt;type].capacity;</pre><pre>  return (wp-&gt;status == ALIVE &amp;&amp; 4 * m &lt; 3 * n);
}
</pre> <p>Of course, it does not make sense that dead worms are hungry. Then why are we testing for it? To make this routine more robust. When we make a worm die, we simply change its status. We do not change its stomach value. So, just in case you call this routine with such a way ...</p>
<p class="endli"></p>
</li>
<li>
<pre>
POSITION posOfHead(WORM * wp)
{
  return lastSeg(wp)-&gt;p;
}
</pre><p> Is a one-liner routine worth the hassle? Yes. For the abstraction it provides. Just as the lastSeg() macro was worth it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The design of <a class="el" href="control_8cpp.html#adaecbeb244fe81df4948e02951cbaffb">userControl()</a> satisfies a critical goal that while paused, keys that change the speed etc. are still active. A simple solution such as</p>
<pre>
 default:
    getch();    /* wait until the next key press */
    ...
</pre><p>wont do that.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">To Be Done: Do we do anything with Cannibals? crawling over itself, or each other: prevent/do-better<br />
</p>
<p>improve efficiency, e.g., identify repeated showing of the same msgs etc.</p>
<p class="endli"></p>
</li>
</ol>
<p>-eof- </p>
<hr/>
<p> <a href="https://cecs.wright.edu/~pmateti/copyright.html">Copyright &copy;</a> 2016 <a href="https://cecs.wright.edu/~pmateti">Prabhaker Mateti</a></p>
</body>
</html>
