# -*- mode: org -*-
#+DATE: 2016-02-15 2020-09-02
#+TITLE: Quick Sort
#+AUTHOR: Prabhaker Mateti
#+DESCRIPTION: Software Engineering
#+HTML_LINK_UP: ../
#+HTML_HEAD: <style> P {text-align: justify} code, pre {color: brown;} @media screen {BODY {margin: 10%} }</style>
#+BIND: org-html-preamble-format (("en" "<a href=\"../../\"> ../../</a>"))
#+BIND: org-html-postamble-format (("en" "<hr size=1>Copyright &copy; 2016 %e &bull; <a href=\"http://www.wright.edu/~pmateti\"> www.wright.edu/~pmateti</a>  %d"))
#+STARTUP:showeverything
#+OPTIONS: toc:nil

* Background

** History

1. Quicksort was contributed by Hoare in 1962. Hundreds of subsequent
   papers!

2. Over the decades of teaching, we "know" that only a few students
   understand Quicksort.  Why?  Bad teaching? Poor student?

** Optimal Sorting

2. For an array of size n, the best we can do is O(n lg n).
   Quicksort and Heapsort are both O(n lg n).

1. Our interest is not in the perf analysis.  Nor in the performance
   itself.

** Relevance to SE

1. This is a good example to extrapolate to Software Engineering
   issues.

** Specs

1. Signature: Quicksort(lo, hi).  

1. Array to be sorted: A[] of integers.  Low index 1, high index n.
   Global.  Quicksort(1, n). n >= 1.

1. Notation: A[lo .. hi] stands for the seq of elements A[lo],
   .., A[hi]. [not bag, not set] 

1. Pre:: true;; 

1. Post::
   1. hi >= lo and sorted(A, lo, hi) and permuted(A.old, A, lo, hi),
      *or*
   2. hi < lo and A[] is unchanged, i.e., equal(A.old, A, lo, hi).

* Partitioning Idea

1. Quicksort(lo, hi). Focus only on A[lo] .. A[hi].  Assume hi >= lo.
   Leave other elements of A[] untouched.

2. Pick a value z := A[x], lo >= x >= hi.  (The choice of z has an
   impact on performance.)

3. Permute the elements of A[] so that any A[lo .. p] <= z < any A[p+1
   .. hi].
   1. permuted(A.old, A, lo, hi),
   2. p may equal lo - 1 (so A[lo .. p] is empty),
   2. p may equal hi (so A[p+1 .. hi] is empty),

4. Quizz: At the end of the above, is A[x] equal to z?

4. Then do 
   1. Quicksort(1, p)
   2. Quicksort(p+1, n)

5. All of this is elegantly discussed in (cite) [Foley and Hoare 1971].

* A Few Implementations

1. http://algs4.cs.princeton.edu/lectures/23Quicksort.pdf From the
   book by Sedgewick and Wayne.

1. http://gauss.ececs.uc.edu/Courses/C321/html/quicksort.java.html

1. Exercise: Suppose we give you the primitive operation: exchange(i,
   j) that excahnges the i-th element of the array with the j-th
   element.  If we use this op exclusively, the permutation property
   is guaranteed.  Rewrite Quicksort using exchange().  No array[x] :=
   e are permitted.

* References


1. C. A. R. Hoare, Quicksort, The Computer Journal, Volume 5, Issue 1,
   1962, Pages 10â€“16, https://doi.org/10.1093/comjnl/5.1.10, PDF at
   https://academic.oup.com/comjnl/article/5/1/10/395338.  Required
   Reading.

1. Foley, Michael, and Charles Antony Richard Hoare. "Proof of a
   recursive program: Quicksort." The Computer Journal 14.4 (1971):
   391-395.  Recommended Reading.

1. Sedgewick, R. Quicksort Ph. D. Dissertation, Advisor: Donald Knuth,
   Computer Science Dept., Stanford University (May 1975) Report
   STAN-CS-75-492, 1975.  Reference.

1. Sedgewick, Robert, and Jon Bentley. "Quicksort is optimal."
   Knuthfest, Stanford University, Stanford
   (2002). https://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf
   Recommended Reading.

1. [Princeton Book] Robert Sedgewick and Kevin Wayne,
   https://algs4.cs.princeton.edu/ 4th Edition; Section on Quicksort.
   Required Reading.  https://algs4.cs.princeton.edu/23quicksort/

1. Bentley, Jon L., and M. Douglas McIlroy. "Engineering a sort
   function." Software: Practice and Experience 23.11 (1993):
   1249-1265.  Required Reading.

1. http://bigocheatsheet.com/ [Big-Oh Cheatsheet] Know Thy
   Complexities!  Includes "Array Sorting Algorithms".  Highly
   Recommended Visit.

1. http://algs4.cs.princeton.edu/lectures/23Quicksort.pdf From the
   book by Sedgewick and Wayne.  Highly
   Recommended Visit.
