<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Actors</title>
<!-- 2014-04-29 Tue 00:58 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Prabhaker Mateti" />
<meta  name="description" content="CEG7370 Distributed Computing"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style> P {text-align: justify} code {font-family: monospace; font-size: 10pt;color: brown;} @media screen {BODY {margin: 10%} }</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="preamble" class="status">
<a href="../../Top/">WSU CEG 7370 Distributed Computing</a> | <a href="./actorsAkkaScala.html"> Actors Akka Scala Overview</a> | <a href="./actorsSlides.html"> Slides</a>
</div>
<div id="content">
<h1 class="title">Actors</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Actors Overview</a></li>
<li><a href="#sec-2">2. Actor Standard Model</a></li>
<li><a href="#sec-3">3. Actor Standard Model - More Details</a></li>
<li><a href="#sec-4">4. Examples of Actor Programs: Set, &#x2026;</a></li>
<li><a href="#sec-5">5. Actor Systems</a></li>
<li><a href="#sec-6">6. Discussion</a></li>
<li><a href="#sec-7">7. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Actors Overview</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>Actors were introduced by Carl Hewitt (MIT) and co-researchers in the 1970s.
</li>

<li>Actors are now part of many programming languages: C++/Act++, Java, Erlang,
Scala, Scheme, Clojure, <a href="http://iolanguage.org/">Io</a>, Ruby; in Reia, all objects are actors.
</li>

<li>The semantics of "actors" in these PL are <b>not</b> the same.
</li>

<li>By "standard" model we are referring to the description given
by Hewitt and his co-researchers.
</li>
</ol>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Actors Overview - By Carl Hewitt</h3>
<div class="outline-text-3" id="text-1-1">
<ol class="org-ol">
<li>from <a href="http://arxiv.org/abs/1008.1459">Parallelism and Concurrency in the Actor Model</a>
</li>

<li>An Actor is a computational entity that, in response to a message
it receives, can concurrently:

<ol class="org-ol">
<li>send messages to addresses of Actors that it has;
</li>
<li>create new Actors;
</li>
<li>designate how to handle the next message it receives.
</li>
</ol>
</li>

<li>There is no assumed order to the above actions and they could be
carried out concurrently.  In addition, two messages sent
concurrently can be received in either order.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Actor Standard Model</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>[from Varela's PhD 2001] <img src="./fig-actors.png" alt="fig-actors.png" /> 
</li>
</ol>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Actor Standard Model-1: Structure</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>Think of <b>actors</b> as [tiny] independent processes/threads.  May be:
think of an actor as a person.  Disassociate "thread" with Java or
Linux threads.

<ol class="org-ol">
<li>Every actor is assigned a unique name/ address.  [Similar to pid, but
abstract.]
</li>
<li>An actor knows the addresses of <b>some</b> of the actors.
</li>
<li>An actor does not contain other actors.
</li>
</ol>
</li>

<li>Each actor has its own (local/private) state.

<ol class="org-ol">
<li>Its own address space.
</li>
<li>Includes a pool (queue? bag?) of messages: <b>mailbox</b>.
</li>
<li>There is no shared memory/state among actors.
</li>
</ol>
</li>

<li>No global clock.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Actor Standard Model-2: Mailbox</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>Idealized mailbox.  Can be empty.  Never becomes "full".  Do not
think: Unix-like mailboxes.
</li>

<li><code>actorName ! msg</code> Sender never blocks.  No handshake. (Overloading
of CSP notation.)
</li>

<li>Sent messages are never lost.
</li>

<li>Received messages are "processed", one at a time. The processed msg
is no longer in the mailbox.
</li>

<li>When the mailbox is empty, the actor is idle.
</li>

<li>Messages may not arrive in the order sent.  Even though A sent to
B, m1 first, and m2 second, B may receive m2 first, and m1 second.
</li>

<li>Spurious messages do not happen.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Actor Standard Model-3: Computation</h3>
<div class="outline-text-3" id="text-2-3">
<ol class="org-ol">
<li><b>Reactive</b>: Actor computation is performed as a reaction to
messages.  Other than initialization.
</li>

<li>Single thread.  An individual actor is sequential.  A collection of
actors is concurrent.
</li>

<li>Each actor has its own methods. <b>Once-only</b> assignment; recursion;
if-exp; no loops;
</li>

<li>An actor can create others dynamically.  It can retain the address
of the newly created actor.
</li>

<li>After a msg is processed, the actor A can <b>become</b> a different actor B.
</li>

<li>The messages remaining will be processed by B.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Actor Standard Model-4: Processing a Message</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>Send asynchronous messages. [Send is never blocking.]
</li>
<li>Restricted to actors whose addresses it has.
</li>
<li>Can send the address as (part of) a message.
</li>
<li>Can send messages to self.
</li>
<li>Sender and receiver can agree on the structure of content. (I.e.,
marshalling is implicit.)
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Actor Standard Model-5: A Tiny Example</h3>
<div class="outline-text-3" id="text-2-5">
<ol class="org-ol">
<li>We will use a quickly-made-up language to illustrate.
</li>

<li>Do not imagine an obvious implementation in C++, Java or Scala.
Implementation techniques of actors are now so advanced that Akka
claims X actors in Y.
</li>

<li>Let us build an actor that behaves like a variable of type integer.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Actor Standard Model-5: An Integer Variable</h3>
<div class="outline-text-3" id="text-2-6">
<ol class="org-ol">
<li><div class="org-src-container">

<pre class="src src-pseudo">intvar: actor(z: integer) {
  val myx: integer = z
  receive msg {
    case msg.op = set(x): myx := x
    case msg.op = get() : msg.sender ! myx
  }
}

var a: actor = create intvar(5)  // external to the actors
</pre>
</div>
</li>

<li>Repeated assignments are not permissible.  Use <code>become</code>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> Actor Standard Model-5: An Integer Variable, contd</h3>
<div class="outline-text-3" id="text-2-7">
<ol class="org-ol">
<li>Repeated assignments are not permissible.  Use <code>become</code>
<div class="org-src-container">

<pre class="src src-pseudo">intvar: actor(z: integer) {
  val myx: integer = z
  receive msg {
    case msg.op = set(x): become create intvar(x)
    case msg.op = get() : msg.sender ! myx
  }
}

var a: actor = create intvar(5)  // external to the actors
var i: integer = a ! get()       // i = 5
a ! set(34)                      // does not return any value
var j: integer = a ! get()       // j = 34
</pre>
</div>
</li>

<li>Even after a <code>become</code>, the actor <code>a</code> is still available as a target
for send.
</li>

<li>As is, the actor <code>a</code> knows of no other actors.  We can mod the
above to collect <code>msg.sender</code> as it receives messages.
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Actor Standard Model - More Details</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Actors' Names</h3>
<div class="outline-text-3" id="text-3-1">
<ol class="org-ol">
<li>Each actor is assigned a unique immutable name ["address", or ref].
</li>

<li>This name cannot be computed/guessed.
</li>

<li>An actor can have the name of another at build time.
</li>

<li>An actor can retain the names of actors that it creates.
</li>

<li>A name may be sent as part of a msg.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Encapsulation</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li>Encapsulation as used in OOP.
</li>

<li>An actor has no mechanism to share its state with other actors
[other than messaging]
</li>

<li>An actor cannot access, in its own run-time stack, the internal
state of another actor.
</li>

<li>The state of an actor is changeable only through the actors own
actions.
</li>

<li>Safe Messaging: Messages should have call-by-value semantics.
After delivery, the message is only in the address space of the
receiver-actor.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Fair Scheduling</h3>
<div class="outline-text-3" id="text-3-3">
<ol class="org-ol">
<li>Weak fairness.  Recall its def in <a href="../FormalMethods/temporal-logic.html">temporal logic</a>.
</li>

<li>Every actor is eventually scheduled to do its computation.
</li>

<li>So, even in the presence of actors running an infinite loop or
blocked on an I/O or system call other actors are not starved.
</li>

<li>Every message sent is eventually delivered to its intended mailbox
(unless its actor is permanently "disabled").
</li>

<li>These requirements may make the implementation expensive.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Location Transparency</h3>
<div class="outline-text-3" id="text-3-4">
<ol class="org-ol">
<li>An actor's address is not based on its location.
</li>

<li>The actors an actor knows could be on the same core, on the same
CPU, or on a different node in a network.
</li>

<li>A consequence of location transparency is state encapsulation.
</li>

<li>Location transparent naming facilitates migration of actors to
different nodes.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Mobility</h3>
<div class="outline-text-3" id="text-3-5">
<ol class="org-ol">
<li>Mobility: A computation (can) move(s) across different nodes.
</li>

<li>Strong mobility: Movement of both code and execution state. 
</li>

<li>Weak mobility: Movement of code only.
</li>

<li>Transparent Migration.  
</li>

<li>Migration enables load-balancing and fault-tolerance.
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Become</h3>
<div class="outline-text-3" id="text-3-6">
<ol class="org-ol">
<li>Behavior is replaced after one msg is processed.
</li>

<li>Essentially another actor's behavior substitutes.
</li>

<li>Adress remains the same.
</li>

<li>When no "become" is defined, the behavior remains as-is.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Examples of Actor Programs: Set, &#x2026;</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>In CSP, we did a small set of integers.  Not only "small" but
statically fixed sized set.  Why?  Because all processes need to be
defined at "compile"-time.
</li>

<li>Build an actor system for a finite, but arbitrarily large, set of
integers.
</li>

<li>Outline.  Messages handled: has(x), insert(x).  No delete(x).  Each
actor holds one integer.  Actors form conceptually a linked list.
Initially, construct the receptionist actor empty handed.  On
insert(x) this becomes one holding x inserts a new empty handed
actor as next.
</li>

<li>Details.  Your Exercise!  (See the next example.)
</li>
</ol>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> A Stack</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li>Build a system of actors that behaves as a stack of integers.  From
an external entity, the "lead" actor receives request-to-do
messages: push(x), pop, top, isEmpty.  Reply to the last three
requests.  Assume valid requests.
</li>

<li>Architecture.  Each actor holds one element of the stack.  It also
has a reference to the next actor of the stack.  If this ref is
nil, this is the last actor of the stack.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> A Stack, contd-1</h3>
<div class="outline-text-3" id="text-4-2">
<ol class="org-ol">
<li>We show only push and pop implemented.

<div class="org-src-container">

<pre class="src src-pseudo">stackNd: actor(elm: actor, lnk: actor) {
    receive msg {
      case msg.op = pop():
        if (elm != NIL) {
          become lnk
          msg.sender ! elm
        }
      case msg.op = push(X):
        P = create stackNd(elm, lnk)
        become create stackNd(create itemvar(X), P)
    }
}
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> A Stack, contd-2</h3>
<div class="outline-text-3" id="text-4-3">
<ol class="org-ol">
<li>The top of the stack is the receptionist in this actor system.
</li>

<li>It was the only actor of the system created externally.  It is
created with a NIL elm, and NIL lnk.
</li>

<li>A pop operation changes the stack as follows:
</li>
</ol>

<div class="org-src-container">

<pre class="src src-scala">      ---------     ---------      ---------
 ---&gt;| 3  | --|---&gt;| 4  |  --|---&gt;| NIL|NIL|
     ---------      ---------      ---------

BECOMES

      ----------     -------      ---------
 ---&gt;|forwarder|---&gt;| 4 | --|---&gt;| NIL | NIL|
      ----------     -------      ---------
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> A Stack, contd-3</h3>
<div class="outline-text-3" id="text-4-4">
<ol class="org-ol">
<li>Discussion: A stack is not a "good match" for distributed computing
&#x2013; any model.  If concurrent processes push and pop from the same
stack, there are no guarantees about the order of content received
back from pops.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> A Recursive Factorial</h3>
<div class="outline-text-3" id="text-4-5">
<div class="org-src-container">

<pre class="src src-scala">aux: actor(n: nat, r: actor) {
  receive msg {
    <span style="color: #a020f0;">case</span> <span style="color: #a0522d;">msg.op</span> = nat(k): r ! n * k
  }
}

factorial: actor() {
  receive msg {
    <span style="color: #a020f0;">case</span> <span style="color: #a0522d;">msg.op</span> = fac(n, a):
      <span style="color: #a020f0;">if</span> (n = 0) a ! nat(1)
      <span style="color: #a020f0;">else</span> {
        F = create aux(n, a)
        self ! fac(n - 1, F)
      }
  }
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Actor Systems</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li>A finite set of actors and a finite set of pending messages.
</li>

<li>Receptionists: Actors that may receive messages from (external)
actors.
</li>

<li>External Actors that may be sent (output) messages.
</li>

<li>External actors simply hold all communications sent to it until the
system is composed with another that contains the actor in
question.
</li>

<li>External actors must respond to a communication telling it to
forward all its mail to the connected actor.
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Discussion</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li>A collection of classic processes with no shared variables
whatsoever can be considered to be based on actor model.  The
conversion to standard actor model is non-trivial only because we
must eliminate loops and var-assignments.
</li>

<li>Topology.  Who can send to who?  Dynamic in Actors.  Fixed in CSP.
</li>

<li>"Channels" specify the type of messages that can be accepted.  The
mailbox of an actor is a channel that accepts any type of message.
Messages that are not matched by any of the case clauses will
remain in the mailbox, rather than causing an error.
</li>
</ol>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Actors Long Term Objective</h3>
<div class="outline-text-3" id="text-6-1">
<ol class="org-ol">
<li>"The Actor Model is intended to provide a foundation for
inconsistency robust information integration."  &#x2013; Carl Hewitt

<ol class="org-ol">
<li>We should expect large scale gathering of info to be
inconsistent.
</li>

<li>Robustness in the presence of inconsistency.
</li>
</ol>
</li>

<li>"Persistence. Information is collected and indexed."
</li>

<li>"Concurrency: Work proceeds interactively and concurrently,
overlapping in time."
</li>

<li>"Quasi-commutativity: Information can be used regardless of whether
it initiates new work or become relevant to ongoing work."
</li>

<li>"Sponsorship: Sponsors provide resources for computation, i.e.,
processing, storage, and communications."
</li>

<li>"Pluralism: Information is heterogeneous, overlapping and often
inconsistent. There is no central arbiter of truth."
</li>

<li>"Provenance: The provenance of information is carefully tracked and
recorded."
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Comparison of Execution Semantics</h3>
<div class="outline-text-3" id="text-6-2">
<p>
as of 2009
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left">SALSA</td>
<td class="left">Scala</td>
<td class="left">Kilim</td>
<td class="left">AArch</td>
<td class="left">JavAct</td>
<td class="left">Foundry</td>
<td class="left">JetL</td>
</tr>

<tr>
<td class="left">State Encap</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">Safe Message</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">No</td>
</tr>

<tr>
<td class="left">Fair Sched</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">No</td>
</tr>

<tr>
<td class="left">Loc Transpar</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">Mobility</td>
<td class="left">Yes</td>
<td class="left">No</td>
<td class="left">No</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">Yes</td>
<td class="left">No</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">(v1.1.2)</td>
<td class="left">(v2.7.3)</td>
<td class="left">(v0.6)</td>
<td class="left">(v0.1.3)</td>
<td class="left">(v1.5.3)</td>
<td class="left">(v1.0)</td>
<td class="left">(v0.1.7)</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Encapsulation Violation</h3>
<div class="outline-text-3" id="text-6-3">
<p>
A program written in the Scala Actors shows violation of state
encapsulation which may cause two actors to simultaneously execute the
critical section.
</p>

<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">object</span> <span style="color: #a0522d;">semaphorenotok</span> {
  <span style="color: #a020f0;">class</span> <span style="color: #228b22;">SemaphoreActor</span>() <span style="color: #a020f0;">extends</span> <span style="color: #228b22;">Actor</span> {
    ...
    <span style="color: #a020f0;">def</span> <span style="color: #0000ff;">enter</span>() {
      <span style="color: #a020f0;">if</span> (num &lt; MAX) {
        <span style="color: #b22222;">// </span><span style="color: #b22222;">critical section</span>
        num = num + 1; }}
  }

  <span style="color: #a020f0;">def</span> <span style="color: #0000ff;">main</span>(<span style="color: #a0522d;">args</span>: <span style="color: #228b22;">Array[String]</span>): <span style="color: #228b22;">Unit </span>= {
    <span style="color: #a020f0;">var</span> <span style="color: #a0522d;">gate</span> = <span style="color: #a020f0;">new</span> SemaphoreActor()
    gate.start
    gate ! <span style="color: #8b2252;">"enter"</span>
    gate.enter
  }
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Starvation</h3>
<div class="outline-text-3" id="text-6-4">
<p>
A program written in the Scala Actors showing an Actor "busy-waiting"
for a reply.  In the absence of fair scheduling, such an actor can
potentially starve other actors. [Figure 3 ref1]
</p>

<div class="org-src-container">

<pre class="src src-scala"><span style="color: #a020f0;">object</span> <span style="color: #a0522d;">fairness</span> {
  <span style="color: #a020f0;">class</span> <span style="color: #228b22;">FairActor</span>() <span style="color: #a020f0;">extends</span> <span style="color: #228b22;">Actor</span> {
  ...
  <span style="color: #a020f0;">def</span> <span style="color: #0000ff;">act</span>() { loop { react {
    <span style="color: #a020f0;">case</span> (<span style="color: #a0522d;">v</span> : <span style="color: #228b22;">int</span>) =&gt; {
      data = v }
    <span style="color: #a020f0;">case</span> (<span style="color: #8b2252;">"wait"</span>) =&gt; {
      <span style="color: #b22222;">// </span><span style="color: #b22222;">busy-waiting section</span>
      <span style="color: #a020f0;">if</span> (data &gt; 0) println(data)
      <span style="color: #a020f0;">else</span> self ! <span style="color: #8b2252;">"wait"</span> }
    <span style="color: #a020f0;">case</span> (<span style="color: #8b2252;">"start"</span>) =&gt; {
      calc ! (<span style="color: #8b2252;">"add"</span>, 4, 5)
      self ! <span style="color: #8b2252;">"wait"</span> }}}
  }}}
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> References</h2>
<div class="outline-text-2" id="text-7">
<ol class="org-ol">
<li>Carl Hewitt, "Actor Model of Computation: Scalable Robust
Information Systems," 2013.  A very deep conceptual
paper. <a href="http://carlhewitt.info">http://carlhewitt.info</a>.  Highly Recommended Reading
</li>

<li>Rajesh K. Karmani, Gul Agha, "Actors." In <i>Encyclopedia of Parallel
Computing</i>, pp. 1-11. Springer US, 2011.  Web search for its pdf.
Required Reading
</li>

<li><a href="http://en.wikipedia.org/wiki/Actor_model">http://en.wikipedia.org/wiki/Actor_model</a>  Recommended Reading
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<hr size=1><a href="http://www.wright.edu/~pmateti"> Prabhaker Mateti </a> &bull; created via <a href="http://www.emacswiki.org/emacs/"> emacs</a> + <a href="http://orgmode.org/worg/"> org-mode</a>
</div>
</body>
</html>
