<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Distributed Systems with Akka</title>
<base target="_self">
<base target="_top">
<style type="text/css">
  a:hover      { color: blue; background-color: yellow; }
  a:active     { color: white; background-color: green;}
  p { text-align: justify }
  li {text-align: justify;}
  pre {border:blue 1px dotted; color:brown}
  code.brown {color:brown}
  @media screen {BODY {margin: 12%;} }
  body {counter-reset: chapter; counter-reset: section;}
  h2:before {content: counter(section) ". "; counter-increment: section;}
  h2 {counter-reset: subsection;}

  h3:before {content: counter(section) "." counter(subsection) " " ;
  counter-increment: subsection;}
</style>

<link href="http://www.cs.wright.edu/~pmateti/SyntaxHighLighter/styles/shCoreEclipse.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="http://www.cs.wright.edu/~pmateti/SyntaxHighLighter/scripts/shCore.js"></script>
<script src="http://www.cs.wright.edu/~pmateti/SyntaxHighLighter/scripts/shAutoloader.js" type="text/javascript"></script>
<script type="text/javascript" src="http://www.cs.wright.edu/~pmateti/SyntaxHighLighter/scripts/shBrushXml.js"></script>
<script type="text/javascript" src="http://www.cs.wright.edu/~pmateti/SyntaxHighLighter/scripts/shBrushJava.js"></script>
<script type="text/javascript">  SyntaxHighlighter.defaults['gutter'] = true;
SyntaxHighlighter.all();</script>
</head>

<body>
<div style="text-align:right">This article is from
<a href="http://www.javaworld.com/article/2078775/scripting-jvm-languages/open-source-java-projects-akka.html">
www.javaworld.com</a>
by <a href="#Steven Haines">Steven Haines</a>, May 8, 2013; <br>
Reformatted for use in
<a href="http://cecs.wright.edu/~pmateti/Courses/7370/">
WSU CEG 7370</a> | 
<a href="#Hello, Message!">Hello, Message!</a> |
<a href="#Computing prime numbers with Akka">
Prime Numbers with Akka</a><br>
Pages: &nbsp;&nbsp; 1
<a href="#Page 2"> &nbsp;&nbsp; 2</a>
<a href="#Page 3"> &nbsp;&nbsp; 3</a>
<a href="#Page 4"> &nbsp;&nbsp; 4</a>
<a href="#Page 4"> &nbsp;&nbsp; 5</a>
<a href="#Page 6"> &nbsp;&nbsp; 6</a><br>

</div>

<h1>Open source Java projects: Akka</h1>

<p>
<i>Building distributed systems for concurrent and scalable Java
applications</i></p>

<p>
  The actor model is a message-passing paradigm that resolves some of
  the major challenges of writing concurrent, scalable code for today's
  distributed systems. In this installment of <i>Open source Java
    projects</i>, Steven Haines introduces Akka, a JVM-based toolkit and
  runtime that implements the actor model. Get started with a simple
  program that demonstrates how an Akka message passing system is wired
  together, then build a more complex program that uses concurrent
  processes to compute prime numbers.
</p><p> If you have experience
    with <a href="http://www.javaworld.com/channel_content/jw-threads-index.html">traditional
      concurrency programming</a>, then you might appreciate
    the <a href="http://www.javaworld.com/javaworld/jw-02-2009/jw-02-actor-concurrency1.html">actor
      model</a>, which is a design pattern for writing concurrent and
    scalable code that runs on distributed systems. Briefly, here's how
    the actor model works:
</p><ol><li>Rather than invoking an object directly, you construct a message and send it to the object (called an <em>actor</em>) by way of an actor reference.</li><li>The actor reference stores the message in a mailbox.</li><li>When a thread becomes available, the engine running the actor delivers that message to its destination object.</li><li>When the actor completes its task, it sends a message back to the originating object, which is also considered an actor.</li></ol><p>
You might suspect that the actor model is more of an event-driven or <a href="http://www.javaworld.com/javaworld/jw-03-2009/jw-03-actor-concurrency2.html">message-passing</a> architecture than a strict concurrency solution, and you would be right. But <em>Akka</em> is a different story: an actor model implementation that enables developers to accomplish impressively high concurrency at a very low overhead.
</p>


<h2>Re-thinking concurrency with Akka (and Scala)</h2>

<p>
Actors provide a simple and high-level abstraction for concurrency and
parallelism. They support asynchronous, non-blocking, and
high-performance event-driven programming, and they are lightweight
processes. (Akka's founding
company, <a href="http://www.javaworld.com/community/?q=node/8429">Typesafe</a>,
claims up to 2.7 million actors per gigabyte of RAM.) Akka
and <a href="http://www.javaworld.com/javaworld/jw-03-2009/jw-03-actor-concurrency2.html">other
message-passing frameworks</a> offer a workaround to the challenges of
multithreaded programming (see the sidebar "What's wrong with
multithreaded programming?"), while also meeting some of the emergent
needs of enterprise programming:
</p><ul><li><em>Fault tolerance</em>: Supervisor hierarchies support a "let-it-crash" semantic and can run across multiple JVMs in a truly fault tolerant deployment. Akka is excellent for highly fault-tolerant systems that self-heal and never stop processing.</li><li><em>Location transparency</em>: Akka is designed to run in a distributed environment using a pure message-passing, asynchronous strategy.</li><li><em>Transactors</em>: Combine actors with software transaction memory (STM) to form transactional actors, which allow for atomic message flows and automatic retry and rollback functionality.</li></ul><p>
Since the actor model is relatively new to most Java developers, I'll explain how it works first, then we'll look at how it's implemented in Akka. Finally, we'll try out the Akka toolkit in a program that computes prime numbers.
</p><div class="textbox"><h4 class="textboxhead">What's wrong with multithreaded programming?</h4>
<p>
<a href="http://www.javaworld.com/javaworld/jw-06-2012/120626-modern-threading.html">Multithreaded programming</a> basically means running multiple copies of your application code in their own threads and then synchronizing access to any shared objects. While it's a complex issue, multithreaded programming has three major fault lines:
</p>
<ul><li><strong>Shared objects</strong>: Whenever multiple threads access shared objects there is always the danger that one thread will modify the data upon which another thread is operating underneath it. Typically, developers solve this issue by encapsulating the dependent functionality in a <a href="http://www.javaworld.com/jw-06-2002/jw-0607-java101.html">synchronized method or synchronized block of code</a>. Numerous threads may attempt to enter that code block, but only one thread will get through; the others will wait until it completes. This approach protects your data, but it also creates a point in your code where operations occur serially.</li><li><strong>Deadlock</strong>: Because we need to synchronize access to code that operates on shared resources, <a href="http://www.javaworld.com/javaworld/jw-10-2001/jw-1012-deadlock.html">deadlock</a> sometimes occurs. In code synchronization (as described above), the first thread that enters a synchronized block obtains the lock, which is owned by the object on which the operation is synchronized. Until that lock is released, no other thread is permitted to enter that code block. If thread 1 obtains the lock to synchronized block 1, and thread 2 obtains the lock to synchronized block 2, but it happens that thread 1 needs access to synchronized block 2 and thread 2 needs access to synchronized block 1 then the two threads will never complete and are said to be <em>deadlocked</em>.</li><li><strong>Scalability</strong>: Managing multiple threads in a single JVM is challenging enough, but when you need to <a href="http://www.javaworld.com/javaworld/jw-03-2013/130301-jvm-performance-optimization-java-scalability.html">scale the application across multiple JVMs</a> the problem increases by an order of magnitude. Typically, running concurrent code across multiple JVMs involves storing shared state in a database and then relying on the database to manage concurrent access to that data.</li></ul></div>

<h2>Akka and the actor model</h2><p>
Akka is an open source toolkit and runtime that runs on the JVM. It's written in <a href="http://www.javaworld.com/community/?q=node/13321">Scala</a> (a language often touted for concurrency) but you can use Java code (or Scala) to call all of its libraries and features.
</p><p>
The principle design pattern that Akka implements is the <a href="http://www.javaworld.com/javaworld/jw-02-2009/jw-02-actor-concurrency1.html">actor model</a>, as shown in Figure 1.
</p>

<figure style="text-align: center"><a href="http://www.javaworld.com/javaworld/jw-05-2013/images/osjp-akka-fig1.png"><img alt="A
flow diagram of the actor model."
src="http://images.techhive.com/images/idge/imported/article/jvw/2013/05/osjp-akka-fig1-100159565-orig.png"/></a>
<figcaption>Figure 1. Actor model concurrency in Akka </figcaption></figure>
	
	
<div id="article-top-page-number" style="text-align:right"><a name="Page 2"></a>Page 2 of 6</div>

	<p>
The Akka toolkit implements the following actor model components:
</p><ul><li><strong>ActorSystem</strong> is the glue that wires <code>Actor</code>s, <code>ActorRef</code>s, <code>MessageDispatcher</code>s, and <code>Mailbox</code>es together. Programmers use the <code>ActorSystem</code> to configure the desired implementation of each of these components.</li><li><strong>ActorRef</strong> is an addressable location. Messages destined for an underlying <code>Actor</code> are sent to an <strong>ActorRef</strong>.</li><li><strong>MessageDispatcher</strong> is the engine that runs the other parts of the <code>ActorSystem</code> and schedules all its activities. The <code>MessageDispatcher</code>'s main responsibility is to run <code>Mailbox</code>es. When an <code>ActorRef</code> receives a message, it dispatches it to the <code>MessageDispatcher</code>, which puts that message in the message queue for the destination <code>Mailbox</code>.</li><li><strong>Mailbox</strong> is the component that holds <code>Actor</code>s. Every <code>Actor</code> has its own mailbox. When the mailbox receives a slice of time to run, it takes a message from the message queue and invokes the <code>Actor</code> with the message.</li><li><strong>MessageQueue</strong> is the first recipient of new messages. When the <code>MessageDispatcher</code> receives a message from the <code>ActorRef</code>, it delivers that message to the mailbox's <code>Message Queue</code>, where it sits until the mailbox receives CPU cycles to run.</li><li><strong>Actor</strong> is an object that provides a <em>receive</em> method, which is invoked by the mailbox when it has a message to process.</li></ul><p>
To summarize: When you want to invoke the functionality of an actor in Akka, you send a message to the <code>ActorRef</code>. The <code>ActorRef</code> dispatches it to a <code>MessageDispatcher</code>, which delivers it to a <code>Mailbox</code>'s <code>MessageQueue</code>. When the <code>Mailbox</code> receives a thread time slice from the <code>MessageDispatcher</code>, it retrieves the message from the <code>MessageQueue</code> and then invokes the <code>Actor</code>'s <em>receive</em> method, passing it the message.
</p>

<h3>Load balancing and horizontal scalability</h3>

<p>
Akka's message-passing process might sound convoluted but it affords Akka two especially powerful benefits:
</p><ol><li><strong>Load balancing</strong>: The <code>MessageDispatcher</code> can be configured with a one-to-one mapping of threads to actors, but it doesn't have to be. This means that the <code>MessageDispatcher</code> can maintain a <a href="http://www.javaworld.com/javaworld/jw-10-2011/111004-jtip-recursion-in-java-7.html">thread pool</a> that is configured to a sustainable quantity for the hardware on which it is running; but it can have far more actors than it does threads. Your application is still limited by the number of threads running actors, but unless all actors are always busy and using all of their CPU time-slices, this level of abstraction allows Akka to take advantage of actor downtime and support more load than a standard threading model could do.</li><li><strong>Horizontal scalability</strong>: While <em>vertical scalability</em> refers to building out bigger and bigger machines that can individually do more work, <em>horizontal scalability</em> refers to running multiple machines together to complete the work. Akka can easily support horizontal scalability because your application never directly interacts with <code>Actor</code>s, but instead interacts with <code>ActorRef</code>s. The two variations of an <code>ActorRef</code> are <em>local</em> and <em>remote</em>. <em>Local ActorRefs</em> deliver messages to a <code>MessageDispatcher</code> running in the same JVM. <em>Remote ActorRefs</em> send messages to a <code>MessageDispatcher</code> running on a different machine. This proxy/stub model is key to distributed computing; Akka exploits it to gain horizontal scalability without requiring your application to change beyond its Akka configuration.</li></ol>

<h3>Actor hierarchies and the ActorPath</h3><p>
All of this leads to another important concept in the Actor model, and in Akka specifically: <em>Actor hierarchies</em>. All <code>Actor</code>s belong to an actor hierarchy in the <code>ActorSystem</code>. <code>Actor</code>s that can be directly created are called <em>Top Level Actors</em>. The <code>ActorSystem</code> defines two separate hierarchies: a <em>system hierarchy</em> to manage internal tasks and a <em>user hierarchy</em> to define <code>Actor</code>s for your application. The <code>ActorSystem</code> defines a user-level <em>root actor</em>, named <em>Guardian</em>, under which all top-level actors are created. Top-level <code>Actor</code>s are then free to create their own child <code>Actor</code>s (which can then create their own child <code>Actor</code>s, and so forth). Together, the <code>Guardian</code>, <code>Actor</code>s, and their children comprise the user hierarchy.
</p><p>
The final concept that you need to understand in order to effectively use Akka is that all <code>Actor</code>s are named, and there is an addressing scheme for locating Actors, called the <code>ActorPath</code>. Here's an example of an <code>ActorPath</code>:
</p>

<code class="brown">akka://MySystem@MyServer:MyPort/user/MyTopLevelActor/MyChild</code>

<p>
Its components are as follows:
</p><ul><li><code>akka</code> is the name of the scheme, so it will always be "<code>akka</code>".</li><li><code>MySystem</code> is the name of the <code>ActorSystem</code> that owns the <code>Actor</code> being addressed.</li><li><code>MyServer:MyPort</code> is the server and port for the server hosting the <code>Actor</code> (e.g.,192.168.1.1:1234).</li><li><code>user</code> is the name of the guardian, which is always "<code>user</code>" for non-system <code>Actor</code>s</li><li><code>MyTopLevelActor</code> is the name given to a top-level actor when you create an <code>ActorSystem</code>.</li><li><code>MyChild</code> is the name of a child actor. You'll use this name if you're trying to access an actor that is a child of a specified top-level <code>Actor</code>. You can continue down the hierarchy until you reach the actor you're looking for.</li></ul>

<div id="article-top-page-number"  style="text-align:right"><a name="Page 3"></a>Page 3 of 6</div>


<h2>Setting up Akka</h2><p>
Akka can run embedded inside your application or as a standalone server or set of servers. The beauty of Akka is that the code looks the same either way. For the purposes of this article we'll build <code>Actor</code>s and <code>ActorSystem</code>s inside of an application.
</p>

<p>
To build and run Akka applications using Maven, you only need to
include the following dependency in your POM file (note that the
latest artifact as of this writing was version 2.1.2):
</p>

<pre class="brush: xml">&lt;dependency&gt;
  &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
  &lt;artifactId&gt;akka-actor_2.10&lt;/artifactId&gt;
  &lt;version&gt;2.1.2&lt;/version&gt;
&lt;/dependency&gt;
</pre><p>
If you are not using Maven, you'll need to download Akka from the Typesafe <a href="http://typesafe.com/stack/download">homepage</a> and add
<code class="brown">lib/akka/akka-actor_2.10-2.1.2.jar</code>
to your <code>CLASSPATH</code>.
</p>
	
<a name="Hello, Message!"></a>
<h2>Hello, Message!</h2>

<p>
In this section I'll demonstrate the simplest way to build an Akka
application. My generic "Hello World" app will use the default
configuration for most options and will only define a single
actor. This way you'll learn the bare minimum that is required to
build and execute an actor before we try writing a more complex
program. You
can <a href="http://www.javaworld.com/javaworld/jw-05-2013/src/osjp-akka-project-src.zip"><b>download
the project source code</b></a> for this article at any time.
</p>

<p>
As I mentioned earlier, there are several ways to build an Akka
application. This example uses Maven to manage Akka as a dependency
and runs Akka embedded inside of the application itself. Listing 1
shows the contents of the Maven pom.xml file.
</p>

<h4>Listing 1. pom.xml</h4>

<pre class="brush: xml">
&lt;project 
  xmlns="http://maven.apache.org/POM/4.0.0" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.geekcap.akka&lt;/groupId&gt;
    &lt;artifactId&gt;AkkaSample&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;AkkaSample&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.0.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.6&lt;/source&gt;
                    &lt;target&gt;1.6&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                            &lt;mainClass&gt;com.geekcap.akka.HelloActor&lt;/mainClass&gt;
                        &lt;/manifest&gt;
                    &lt;/archive&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;copy&lt;/id&gt;
                        &lt;phase&gt;install&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;


    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
            &lt;artifactId&gt;akka-actor_2.10&lt;/artifactId&gt;
            &lt;version&gt;2.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.10&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</pre><p>
Note that this POM file includes Akka version 2.1.2 as a dependency. In the build section, it sets the Java build version to 1.6, tells Maven to package the dependent JAR files into the target <em>lib</em> directory, and defines a main class to execute.
</p><p>
Akka operates by passing messages to actors, so Listing 2 shows the source code for <code>HelloMessage.java</code>.
</p>

<h4>Listing 2. HelloMessage.java</h4>
<pre class="brush: java">package com.geekcap.akka;
import java.io.Serializable;

public class HelloMessage implements Serializable {
    private String message;

    public HelloMessage(String message)     {
        this.message = message;
    }

    public String getMessage()    {
        return message;
    }

    public void setMessage(String message)    {
        this.message = message;
    }
}
</pre><p>
The <code>HelloMessage</code> class is a simple POJO that implements the <a href="http://www.javaworld.com/community/node/2915">Serializable</a> interface. This is important because if you do move your <code>Actor</code>s to another machine your messages must be serializable. Making all messages serializable ensures that you will not have issues later on.
</p><p>
Listing 3 shows the meat of the Akka code in the <code>HelloActor</code> class.
</p><h4>Listing 3. HelloActor.java</h4>

<pre class="brush: java">package com.geekcap.akka;

import akka.actor.ActorRef;
import akka.actor.ActorSystem;
import akka.actor.Props;
import akka.actor.UntypedActor;

public class HelloActor extends UntypedActor {
    public void onReceive(Object message)    {
        if( message instanceof HelloMessage)        {
            System.out.println( "My message is: " 
              + ((HelloMessage) message ).getMessage() );
        }
    }

    public static void main( String[] args ) {
        ActorSystem actorSystem = ActorSystem.create( "MySystem" );
        ActorRef actorRef = actorSystem.actorOf(
          new Props( HelloActor.class ), "myActor" );
        actorRef.tell( new HelloMessage( "Hello, Akka!" ) );

        try {
            Thread.sleep( 1000 );
        } catch( Exception e ) {}

        actorSystem.stop( actorRef );
        actorSystem.shutdown();
    }
}
</pre>

<p>
Listing 3 defines the <code>HelloActor</code> class, which extends the <code>UntypedActor</code> base class. This class has a single method that needs to be implemented: <code>onReceive()</code>. The <code>onReceive()</code> method is invoked by the <code>HelloActor</code>'s <code>Mailbox</code> when the <code>MessageDispatcher</code> gives the <code>Mailbox</code> a thread time-slice, if there is a message waiting in the <code>Mailbox</code>'s <code>MessageQueue</code>. The message is passed as an object so we check to see if the message received is a <code>HelloMessage</code>. If the message is a <code>HelloMessage</code>, then the <code>HelloActor</code> will invoke the <code>HelloMessage</code>'s <code>getMessage()</code> method to print out the message.
</p>
	
	

<div id="article-top-page-number"  style="text-align:right"><a name="Page 4"></a>Page 4 of 6</div>
			
	<p>
The <code>HelloActor</code> class has a <code>main()</code> method that sets up the <code>ActorSystem</code>. It creates an <code>ActorSystem</code> named "<code>MySystem</code>" and then creates an <code>ActorRef</code> that points to the <code>HelloActor</code> class named "<code>actorRef</code>". The <code>main()</code> method sends the <code>actorRef</code> a new <code>HelloMessage</code> instance with the message "Hello, Akka!" by invoking its <code>tell()</code> method. The <code>tell()</code> method is the mechanism for sending messages to actors asynchronously. The <code>main()</code> method then sleeps for a second and finally shuts down Akka. It shuts down by first telling the <code>ActorSystem</code> to stop the <code>HelloActor</code> actor reference, and then telling the <code>ActorSystem</code> it shut itself down.
</p><p>
<code>HelloMessage</code> doesn't demonstrate how to create a concurrent application using Akka, but it does demonstrate how to create various actor model components (<code>ActorSystem</code>, <code>Actor</code>, and <code>ActorRef</code>), and send messages to an <code>Actor</code> through the <code>ActorRef</code>. The prime number computing program in the next section will demonstrate Akka's concurrency model. You'll also get to see a better approach to shutting down the actor system, using a listener actor.
</p>

<a name="Computing prime numbers with Akka"></a>
<h2>Computing prime numbers with Akka</h2>


<p>
The example application in this section is a <a href="http://www.javaworld.com/javaworld/jw-05-2013//src/osjp-akka-project-src.zip">complete Akka application</a> that computes prime numbers for a given range. For example, if we were to list all of the prime numbers between 1 and 10, we would expect the following output: 1, 2, 3, 5, 7. This program won't be particularly challenging to code, but it will demonstrate how to do following:
</p><ul><li>Create a master actor</li><li>Create a round-robin router to distribute work across multiple worker actors</li><li>Communicate between worker actors and the master actor</li><li>Communicate between the master actor and a listener</li></ul><p>
Not bad for a simple number cruncher!
</p><p>
Figure 2 shows all the moving parts involved in the PrimeCalculator program.
</p>

<figure style="text-align: center">
<a href="http://www.javaworld.com/javaworld/jw-05-2013/images/osjp-akka-fig2.png">
<img alt="A flow diagram of PrimeCalculator."
src="http://images.techhive.com/images/idge/imported/article/jvw/2013/05/osjp-akka-fig2-100159566-orig.png"/></a>
<figcaption>Figure 2. An actor-based system for computing prime
numbers with Akka
</figcaption></figure>

<p>
As shown in Figure 2, the <code>PrimeCalculator</code> provides a <code>calculate()</code> method that sends a number-range message to the <code>PrimeMaster</code> class. The <code>PrimeMaster</code> divides this number range into 10 units and distributes them across 10 <code>PrimeWorker</code>s. The <code>PrimeWorker</code>s complete their work and then publish a <code>Result</code> message back to the <code>PrimeMaster</code>. The <code>PrimeMaster</code> aggregates all 10 <code>Result</code> responses, then publishes the aggregate <code>Result</code> object to the <code>PrimeListener</code>. The <code>PrimeListener</code> writes the results to the screen and then shuts down the <code>ActorSystem</code>.
</p><p>
In the next sections I'll discuss each of the main components of the <code>PrimeCalculator</code> in detail.
</p><h3>NumberRangeMessage and Result</h3><p>
We'll start with the <code>NumberRangeMessage</code> and <code>Result</code> message classes, which are are simple serializable POJOs that contain data to be passed between actors.
</p>

<h4>Listing 4. NumberRangeMessage.java</h4>
<pre class="brush: java">package com.geekcap.akka.prime.message;
import java.io.Serializable;

public class NumberRangeMessage implements Serializable {
    private long startNumber;
    private long endNumber;
    public long getStartNumber() {return startNumber;}
    public long getEndNumber() {return endNumber;}

    public NumberRangeMessage(long startNumber, long endNumber) {
        this.startNumber = startNumber;
        this.endNumber = endNumber;
    }

    public void setStartNumber(long startNumber) {
        this.startNumber = startNumber;
    }

    public void setEndNumber(long endNumber) {
        this.endNumber = endNumber;
    }
}
</pre>

<h4>Listing 5. Result.java</h4>

<pre class="brush: java">package com.geekcap.akka.prime.message;
import java.util.ArrayList;
import java.util.List;

public class Result {
    private List&lt;Long&gt; results = new ArrayList&lt;Long&gt;();
    public Result() {}
    public List&lt;Long&gt; getResults() {return results;}
}
</pre><p>
Both of these classes are pretty self-explanatory.
</p>
	
	
			
<div id="article-top-page-number"  style="text-align:right"><a name="Page 5"></a>Page 5 of 6</div>
		
<h3>PrimeWorker</h3><p>
The <code>PrimeWorker</code> shown in Listing 6, below, examines the number range passed to it and returns a list of all prime numbers within that range.
</p>

<h4>Listing 6. PrimeWorker.java</h4>

<pre class="brush: java">package com.geekcap.akka.prime;

import akka.actor.UntypedActor;
import com.geekcap.akka.prime.message.NumberRangeMessage;
import com.geekcap.akka.prime.message.Result;

public class PrimeWorker extends UntypedActor {
    /**
     * Invoked by the mailbox when it receives a thread timeslice and
     * a message is available
     *
     * @param message   The message to process
     */
    public void onReceive( Object message ) {
        // We only handle NumberRangeMessages
        if( message instanceof NumberRangeMessage ) {
            // Cast the message to a NumberRangeMessage
            NumberRangeMessage numberRangeMessage = 
              (NumberRangeMessage) message;
            System.out.println(
              "Number Rage: " + numberRangeMessage.getStartNumber() + 
              " to " + numberRangeMessage.getEndNumber() );

            // Iterate over the range, compute primes, and return the 
            // list of numbers that are prime
            Result result = new Result();
            for ( long l = numberRangeMessage.getStartNumber();
                   l &lt;= numberRangeMessage.getEndNumber(); l++ ) {
                if( isPrime(l) ) {
                    result.getResults().add(l);
                }
            }

            // Send a notification back to the sender
            getSender().tell( result, getSelf() );
        }
        else {
            // Mark this message as unhandled
            unhandled( message );
        }
    }

    /**
     * Returns true if n is prime, false otherwise
     *
     * @param n     The long to check
     *
     * @return      True if n is prime, false otherwise
     */
    private boolean isPrime( long n ) {
        if( n == 1 || n == 2 || n == 3 ) {
            return true;
        }

        // Is n an even number?
        if( n % 2 == 0 ) {
            return false;
        }

        //if not, then just check the odds
        for( long i=3; i*i&lt;=n; i+=2 ) {
            if( n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
</pre><p>
<code>PrimeWorker</code> is the class that performs the labor of computing prime numbers. It inspects a received message and if it is a <code>NumberRangeMessage</code> it processes it. Otherwise <code>PrimeWorker</code> invokes the <code>unhandled()</code> method to notify its parent that it did not handle the message. <code>PrimeWorker</code>'s logic is actually rather simple: it iterates over the numbers in its number range and then invokes its <code>isPrime()</code> method on each number. After it completes processing it reports back to the <code>PrimeMaster</code>, which it does by calling <code>getSender()</code> to retrieve an <code>ActorRef</code> to the actor that sent the message (<code>PrimeMaster</code>), and then invoking its <code>tell()</code> method with the results. <code>PrimeWorker</code>s run asynchronously, so this "callback" lets the <code>PrimeMaster</code> know that a given worker has completed its task.
</p><h3>PrimeMaster</h3><p>
The <code>PrimeMaster</code> divides the number range passed to it into 10 relatively even chunks and then distributes them to its <code>PrimeWorker</code> router.
</p><h4>Listing 7. PrimeMaster.java</h4><pre class="brush: java">package com.geekcap.akka.prime;

import akka.actor.ActorRef;
import akka.actor.Props;
import akka.actor.UntypedActor;
import akka.routing.RoundRobinRouter;
import com.geekcap.akka.prime.message.NumberRangeMessage;
import com.geekcap.akka.prime.message.Result;

public class PrimeMaster extends UntypedActor {
    private final ActorRef workerRouter;
    private final ActorRef listener;

    private final int numberOfWorkers;
    private int numberOfResults = 0;

    private Result finalResults = new Result();

    public PrimeMaster( final int numberOfWorkers, ActorRef listener ) {
        // Save our parameters locally
        this.numberOfWorkers = numberOfWorkers;
        this.listener = listener;

        // Create a new router to distribute messages out to 10 workers
        workerRouter = this.getContext()
          .actorOf( new Props(PrimeWorker.class ).withRouter(
             new RoundRobinRouter( numberOfWorkers )), "workerRouter" );
    }

    @Override
    public void onReceive( Object message ) {
        if( message instanceof NumberRangeMessage ) {
            // We have a new set of work to perform
            NumberRangeMessage
              numberRangeMessage = ( NumberRangeMessage ) message;

            // Just as a demo: break the work up into 10 chunks of numbers
            long numberOfNumbers = numberRangeMessage.getEndNumber()
                  - numberRangeMessage.getStartNumber();
            long segmentLength = numberOfNumbers / 10;

            for( int i=0; i &lt; numberOfWorkers; i++ ) {
                // Compute the start and end numbers for this worker
                long startNumber = numberRangeMessage.getStartNumber()
                    + ( i * segmentLength );
                long endNumber = startNumber + segmentLength - 1;

                // Handle any remainder
                if( i == numberOfWorkers - 1 ) {
                    // Make sure we get the rest of the list
                    endNumber = numberRangeMessage.getEndNumber();
                }

                // Send a new message to the work router 
                // for this subset of numbers
                workerRouter.tell( new NumberRangeMessage( 
                   startNumber, endNumber ), getSelf() );
            }
        }
        else if( message instanceof Result ) {
            // We received results from our worker: 
            // add its results to our final results
            Result result = ( Result )message;
            finalResults.getResults().addAll( result.getResults() );

            if( ++numberOfResults &gt;= 10 ) {
                // Notify our listener
                listener.tell( finalResults, getSelf() );

                // Stop our actor hierarchy
                getContext().stop( getSelf() );
            }

        }
        else {
            unhandled( message );
        }
    }
}
</pre><p>
The <code>PrimeMaster</code> is a bit more complicated than the <code>PrimeWorker</code>. In its constructor it creates a <code>RoundRobinRouter</code> that distributes messages to a pool of <code>PrimeWorkers</code>. It creates the <code>RoundRobinRouter</code> by first creating the actor with the <code>actorOf()</code> method, but then invoking the <code>withRouter()</code> method on the returned <code>ActorRef</code>. A <a href="http://www.javaworld.com/javaworld/jw-10-2008/jw-10-load-balancing-1.html">round-robin strategy</a> distributes messages to each actor in turn. When it reaches the end of its list it starts over again at the beginning.
</p><p>
The <code>PrimeMaster</code>'s <code>onReceive()</code> method needs to handle two types of messages: a <code>NumberRangeMessage</code> that is received from the <code>PrimeCalculator</code> to start the process and a <code>Result</code> message that is received from each <code>PrimeWorker</code> when it completes its work. The <code>NumberRangeMessage</code> handler divides the work into 10 chunks and dispatches those chunks to the <code>PrimeWorker</code>s by invoking the router's <code>tell()</code> method. The router then handles distributing those messages to workers in a round-robin fashion.
</p><p>
An additional complexity in this handler is that it might miss some messages at the end when the range is divided into chunks of 10 (unless the number of numbers to examine is evenly divisible by 10, in which case there will be a remainder that needs to be accounted for). The last handler ensures that all the numbers are processed by including them all to the end of the range. This is not the best way to distribute numbers to workers because smaller numbers will take less processing time than larger numbers, but it does illustrate the process without adding additional complexity.
</p>
	
			
<div id="article-top-page-number" style="text-align:right"><a name="Page 6"></a>Page 6 of 6</div>
			
		
	
<p>
The <code>Result</code> message handler adds the results from the worker to its final result list and then checks to see if it has received messages from all the workers. Since <code>NumberRangeMessage</code> handler divided the work into 10 chunks, the <code>Results</code> handler counts responses and stops when it has received 10 responses. When it complete it invokes the listener's <code>tell()</code> method with the final results, and then it shuts itself down.
</p>

<h3>PrimeListener</h3><p>
Listing 8 shows the <code>PrimerListener</code>, which is the actor that receives the final results from the <code>PrimeMaster</code>.
</p>

<h4>Listing 8. PrimeListener.java</h4>

<pre class="brush: java">package com.geekcap.akka.prime;

import akka.actor.UntypedActor;
import com.geekcap.akka.prime.message.Result;

public class PrimeListener extends UntypedActor {
    @Override
    public void onReceive( Object message ) throws Exception {
        if( message instanceof Result ) {
            Result result = ( Result ) message;
            System.out.println( "Results: " );
            for( Long value : result.getResults() ) {
                System.out.print( value + ", " );
            }
            System.out.println();

            // Exit
            getContext().system().shutdown();
        }
        else {
            unhandled( message );
        }
    }
}
</pre><p>
The <code>PrimeListener</code> handles <code>Result</code> messages that contain the final results of all <code>PrimeWorker</code> processing. It handles this message by printing all of the values in the <code>Results</code> list, then it shuts down the entire actor system by retrieving its actor context and then invoking the actor system's <code>shutdown()</code> method. This shutdown step is not required if you have additional work to perform. In this example we've reached the end of the work for the application, so we shut down the system so that the application can exit.
</p><h3>PrimeCalculator</h3><p>
Finally, Listing 9 shows the <code>PrimeCalculator</code>, which creates the <code>ActorSystem</code>, configures the <code>PrimeMaster</code> and <code>PrimeListener</code>, and then submits work to the <code>PrimeMaster</code>.
</p>

<h4>Listing 9. PrimeCalculator.java</h4>

<pre class="brush: java">package com.geekcap.akka.prime;

import akka.actor.*;
import com.geekcap.akka.prime.message.NumberRangeMessage;

public class PrimeCalculator {
    public void calculate( long startNumber, long endNumber ) {
        // Create our ActorSystem, which owns and configures the classes
        ActorSystem actorSystem = ActorSystem.create( "primeCalculator" );

        // Create our listener
        final ActorRef primeListener = actorSystem.actorOf
          (new Props(PrimeListener.class), "primeListener");

        // Create the PrimeMaster: we need to define an
        // UntypedActorFactory so that we can control how PrimeMaster
        // instances are created (pass in the number of workers and
        // listener reference

        ActorRef primeMaster = actorSystem.actorOf
         ( new Props(
             new UntypedActorFactory() {
               public UntypedActor create() {
                return new PrimeMaster( 10, primeListener );
               }
             }), "primeMaster" 
         );
        // Start the calculation
        primeMaster.tell(new NumberRangeMessage(startNumber, endNumber));
    }

    public static void main( String[] args )
    {
        if( args.length &lt; 2 ) {
            System.out.println(
             "Usage: java com.geekcap.akka.prime.PrimeCalculator" +
               "&lt;start-number&gt; &lt;end-number&gt;" );
            System.exit( 0 );
        }

        long startNumber = Long.parseLong( args[ 0 ] );
        long endNumber = Long.parseLong( args[ 1 ] );
        PrimeCalculator primeCalculator = new PrimeCalculator();
        primeCalculator.calculate( startNumber, endNumber );
    }
}
</pre><p>
The <code>PrimeCalculator</code> sets up the <code>ActorSystem</code>, the <code>PrimeListener</code>, and the <code>PrimeMaster</code> in its <code>calculate()</code> method. Note that actors live in their own hierarchies, so the <code>PrimeCalculator</code> sets up the <code>PrimeMaster</code> and then the <code>PrimeMaster</code> sets up all of its <code>PrimeWorker</code>s.
</p><p>
The additional complexity in the <code>PrimeMaster</code> <code>ActorRef</code> creation is that we need to pass parameters to the <code>PrimeMaster</code>'s constructor, namely the number of workers to use and a reference to the listener to notify when it is complete. To do this, we create an <a href="http://www.javaworld.com/javaqa/2000-03/02-qa-innerclass.html">anonymous inner class</a> that extends the <code>UntypedActorFactory</code> and overrides its <code>create()</code> method. This allows us to create and optionally configure the <code>PrimeMaster</code> before it is wrapped by an <code>ActorRef</code> and returned to the caller. Finally we start the process by invoking the <code>PrimeMaster</code> <code>ActorRef</code>'s <code>tell()</code> method, passing it the number range received from the command line.
</p><h2>A Maven build for PrimeCalculator</h2><p>
Listing 10 shows the Maven POM file that builds this project. Note that it is the same as the POM file shown in Listing 1, but the <code>mainClass</code> now references <code>PrimeCalculator</code>.
</p>

<h4>Listing 10. pom.xml</h4>

<pre class="brush: xml">
&lt;project
  xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0"
   "http://maven.apache.org/xsd/maven-4.0.0.xsd" &gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.geekcap.akka&lt;/groupId&gt;
    &lt;artifactId&gt;AkkaSample&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;AkkaSample&lt;/name&gt;
    &lt;url&gt;http://maven.apache.org&lt;/url&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.0.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.6&lt;/source&gt;
                    &lt;target&gt;1.6&lt;/target&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                            &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;
                            &lt;mainClass&gt;
                              com.geekcap.akka.prime.PrimeCalculator
                            &lt;/mainClass&gt;
                        &lt;/manifest&gt;
                    &lt;/archive&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;copy&lt;/id&gt;
                        &lt;phase&gt;install&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;copy-dependencies&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;outputDirectory&gt;
                              ${project.build.directory}/lib
                            &lt;/outputDirectory&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;


    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;
            &lt;artifactId&gt;akka-actor_2.10&lt;/artifactId&gt;
            &lt;version&gt;2.1.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.10&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</pre><p>
You can build the project with the following command:
<code class="brown">mvn clean install</code></p>

<p>
You can execute it from the target directory as follows:<br>
<code class="brown">java -jar AkkaSample-1.0-SNAPSHOT.jar 1 23</code></p>

Passing "<code>1 23</code>" to the <code>PrimeCalculator</code> tells it to return all prime numbers between 1 and 23. The output should resemble the following:
</p><pre class="brush: java">Number Rage: 1 to 2
Number Rage: 3 to 4
Number Rage: 5 to 6
Number Rage: 11 to 12
Number Rage: 13 to 14
Number Rage: 15 to 16
Number Rage: 17 to 18
Number Rage: 19 to 23
Number Rage: 9 to 10
Number Rage: 7 to 8
Results: 
1, 2, 3, 5, 11, 13, 17, 19, 23, 7,
</pre><p>
I left the number-range display so that you can see the numbers that each worker is processing. Because processing is asynchronous, the numbers are not in order. This is just an artifact of storing data in a list. As an exercise, try fixing this by changing the <code>List</code> to a <code>TreeSet</code>.
</p><h2>In conclusion</h2><p>
Any application of substance will eventually face concurrency issues; basically, "How can I accomplish all of my work at the same time?" The standard implementation is to manually create threads and then synchronize access to shared objects, in order to ensure that data is not corrupted. This is technically challenging and can lead to problems such as thread depravation, thread deadlock, and scalability issues. Akka resolves these familiar concurrency problems in a different way by implementing the actor model design pattern.
</p><p>
In the actor model, all work units are defined as actors and communication between them is accomplished via message passing. Akka handles all of the underlying threading complexity leaving you to divide your tasks into actors, define messages to pass between actors, and wire together their communication logic. Akka simplifies concurrent code, but more importantly, it provides infrastructure that allows you to scale without changing your application: if necessary, you could start up hundreds of Akka servers to run your actors. Akka seamlessly handles the distribution of messages and communication between actors.
</p><p>
Being able to distribute actors across multiple machines is the real power of Akka, especially for systems where high scalability is a requirement.
</p>

<h3>Learn more about this topic</h3>

<ul><li>Download the <a href="http://www.javaworld.com/javaworld/jw-05-2013//src/osjp-akka-project-src.zip">source code</a> [broken] for this article.</li><li>For more about the actor model, see Alex Miller's two-part series on JavaWorld: <ul><li><a href="http://www.javaworld.com/javaworld/jw-02-2009/jw-02-actor-concurrency1.html">Understanding actor concurrency, Part 1: Actors in Erlang</a></li><li><a href="http://www.javaworld.com/javaworld/jw-03-2009/jw-03-actor-concurrency2.html">Understanding actor concurrency, Part 2: Actors on the JVM</a></li></ul></ul>

<hr size=1>
This article is a reformatted version of
<a href="http://www.javaworld.com/article/2078775/scripting-jvm-languages/open-source-java-projects-akka.html"> http://www.javaworld.com/article/2078775/scripting-jvm-languages/open-source-java-projects-akka.html</a> May 8, 2013 3:42 PM
<p>
Author Bio:
<a name="Steven Haines">Steven Haines</a>  is a technical architect
at Kit Digital, currently working onsite at Disney in Orlando. He is
the founder of <a href="http://www.geekcap.com">www.geekcap.com</a>,
an online education website, and has written hundreds of Java-related
articles as well as three books: <em>Java 2 From
Scratch</em>, <em>Java 2 Primer Plus</em>, and <em>Pro Java EE
Performance Management and Optimization</em>. He lives with his wife
and two children in Apopka, Florida.
</p>


</body>
</html>
