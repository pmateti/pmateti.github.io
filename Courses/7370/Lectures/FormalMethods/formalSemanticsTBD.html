<html>

<head>
<title>Distributed Computing Lectures by Prabhaker Mateti</title>
<meta name="author" content="Prabhaker Mateti">
<meta name="keywords" content="Split binary semaphore, CSP, Linda, RPC, RMI">
<meta name="description" content="Prabhaker Mateti http://www.cs.wright.edu/~pmateti/">

<style type="text/css">
  a:hover      { color: blue; background-color: yellow; }
  a:active     { color: white; background-color: green;}
  @page { size: 8.5in 11in }
  P { text-align: justify }
  TD P { text-align: justify }
  LI { text-align: justify; }
  pre {border:blue 1px dotted;}
  pre.sol {border:green 1px dashed;}
  tt {border:blue 1px dotted;}
  ol.o {padding-left: 0px; }
  sr {border:blue 1px dotted;}
  @media screen {BODY {white; margin: 15%} }
</style>
</head>

<body>

<h3><a href="http://www.cs.wright.edu/~pmateti/Courses/7370/">
CEG 7370:&nbsp;Distributed Computing Principles</a></h3>
<h1>Mathematics of Concurrency</h1>
<h3>Prabhaker Mateti</h3>

<p>This web page is organized in way that is useful during my lecture,
instead of ppt slides.

<p>
This page is about treating concurrency related issues rigorously,
using mathematical logic.  It assumes you read through the
<a href="./assertions.html">
assertions</a>.
<hr size="1">



<h2>Fine Grained Atomicity</h2>

<table width=100%>
<tr><td width="30%" valign=top>
<sr>
S1 :: x := y<br>
S2 :: y := z<br>
S0 :: co  S1 &#8214; S2 oc
</sr>
</td><td>&nbsp;</td>
<td width="60%" valign=top>
Final value of x can be:<br>
old-y or z
</td>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td width="30%" valign=top>
<sr>
S1:: y := 0; z := 0<br>
S2:: x := y + z<br>
S3:: y := 1; z := 2<br>
S0:: S1; co S2 &#8214; S3 oc
</sr>
</td><td>&nbsp;</td>
<td width="60%" valign=top>
Final value of x can be:<br>
0, 1, 2, or 3
</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
<td width="30%" valign=top>
<sr> co x := y + y &#8214; y := 1 oc</sr>
</td>
<td>&nbsp;</td>
<td width="60%" valign=top>
<p>has two references to y. <sr>y + y</sr> can read both the old and
new values of y in either instance.
</p></td>
</tr>
</table>

<p>Below: Shared variables only.

<h3>At-Most-Once Property</h3>

<table width=100%>
<tr><td width="55%" valign=top>
<p>
At-Most-Once(e) ::=<br>
&nbsp;&nbsp;&nbsp;&nbsp;
 for-all x in sharedVars(e):<br>
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
 (nrefs(x, e) &le; 1)</p>

At-Most-Once(x := e) ::= <br>
&nbsp;&nbsp;&nbsp;&nbsp;At-Most-Once(e) &  x not-in readVars(P)<br>
&nbsp;&nbsp;&nbsp;&nbsp;OR<br>
&nbsp;&nbsp;&nbsp;&nbsp;simpleVar(x) <br>
&nbsp;&nbsp;&nbsp;&nbsp;
& refVars(e) disjoint-with writeVars(P)<br>


</td>
<td>&nbsp;&nbsp;</td>
<td width="50%" valign=top>
Simple variable &equiv; a whole variable, not a "part", e.g., array[i];<br>
e is an expression of "this" process;<br>
P stands for any "other" process
</p>

writeVars(P) ::= vars P modifies<br>
readVars(P) ::= vars P reads<br>
refVars(P) ::= vars P reads/writes<br>
sharedVars(e) ::= modified by others<br>
nrefs(x, e) ::= (free) occurs of x in e<br>
</td>
</tr>
</table>

<p>
A statement obeying the At-Most-Once property executes as if it were
atomic.


<h2>Deduction Rules</h2>

<p>Await Rule: &nbsp;&nbsp;
{P & B} S {Q}  &nbsp;&nbsp; &rArr; &nbsp;&nbsp; {P} < await B &rarr; S> {Q}</p>

<p>Unconditional atomic actions
<p>Conditional atomic actions

<p>{Pi} Si {Qi}
&nbsp; &rArr;?
{P1 & P2 & ... & Pn}  co S1&#8214;S2&#8214;...&#8214;Sn oc  {Q1 & Q2 &...& Qn}<br>
<p>No. &nbsp;&nbsp E.g., 
Si::  < x := x + 1 >, &nbsp;
Pi &equiv; {x = 0}, Qi &equiv; {x = 1}

<p>We have interference.

<h3>Critical Assertions</h3>

<p>
Given a proof that {P} S {Q} is a theorem, the critical assertions in
the proof are: (i) Q, and (ii) for each statement T within S that is
not within an await statement, the weakest predicate pre(T) such that
{pre(T)} T {post(T)} is a theorem within the proof.

<p>{P(e)} < x := e > {P(x)}

<p>{P} < S1;  {Q} S2 > {R}


<h3>Non-Interference</h3>

<p>
Assignment action A.  Critical assertion C.</p>

<p>
A does not interfere with C, NI(A, C), if &nbsp;&nbsp;&nbsp;&nbsp; {C & pre(A)} A {C}.

<p>
<p>

<table width=100%>
<tr><td width="35%" valign=top>
<h3>Interference Freedom</h3>

<p>
{Pi} Si {Qi}, 1 &le; i &le; n,<br>
are interference-free if<br>
&nbsp;&nbsp;&nbsp;&nbsp;
for-all A in Si<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for-all C in Sj, i &ne; j,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
NI(A, C) holds.
</td>
<td>&nbsp;&nbsp;</td>
<td width="65%" valign=top>
<h3>Concurrency Rule</h3>

<p>
{Pi} Si {Qi}, 1 &le; i &le; n, are interference-free<br>
&rArr;<br>
{P1 & ... & Pn}
 co S1 &#8214; S2 &#8214; ... &#8214; Sn oc {Q1 & ... & Qn}
</td>
</tr>
</table>

<h2>Weakened Assertions</h2>
<table width=100%>
<tr><td width="30%" valign=top>
<sr>
X0:: x := 0<br><br>
S1:: < x := x + 1><br>
S2:: < x := x + 2><br>
<br>

S0:: X0; co S1 &#8214; S2 oc
</sr>
</td><td>&nbsp;</td>
<td width="60%" valign=top>
<p>
Clearly, post S0 we have x = 3. But, with<br>
{x = 0} S1 { x = 1}<br>
{x = 0} S2 { x = 2}<br>
valid (in isolation), that x = 3 cannot be proven.<br>
<br>
S1 interferes with x = 0, and x = 2.<br>
S2 interferes with x = 0, and x = 1.<br>
</td>
</tr>
</table>

<p>
weaken pre {x = 0} S1 { x = 1} to {x = 0 or x = 2} S1 { x = 1 or x = 3}<br>
weaken pre {x = 0} S2 { x = 2} to {x = 0 or x = 1} S2 { x = 2 or x = 3}<br>

<p>
Claim:  S1 does not interfere with pre(S2).<br>
Proof:<br>
  Show NI(S1, pre(S2)) holds.<br>
i.e., show {pre(S2) & pre(S1)} S1 {pre(S2)}.<br>
i.e., show {(x = 0 or x = 1)  &  (x = 0 or x = 2)} S1 {(x = 0 or x = 1)} holds.<br>
i.e., show {x = 0} S1 {(x = 0 or x = 1)} holds.<br>
i.e., show (x = 0) &rArr; (x+1 = 0 or x+1 = 1) holds.<br>
i.e., show (x = 0) &rArr; (x = -1 or x = 0) holds.<br>
QED<br>

<p>
Claim:  S2 does not interfere with pre(S1).<br>
Proof:  similar<br>

<p>
Now, we can instantiate the Concurrency Rule<br>
{x = 0 or x = 2} S1 { x = 1 or x = 3}<br>
{x = 0 or x = 1} S2 { x = 2 or x = 3}<br>
no interference<br>
&rArr;<br>
{(x = 0 or x = 2) & (x = 0 or x = 1)} co S1 &#8214; S2 oc {(x = 1 or x = 3) & (x = 2 or x = 3)}<br>

<p>
The last line simplifies to 
{x = 0} co S1 &#8214; S2 oc {x = 3}<br>


<h2>Exercises</h2>

<ol>
  <li>
    See the Exercises in Andrews, Chapters 1 and 2.

  <li> Does the precondition and statement {x&nbsp; &ge; 4 } &lt; x := x - 4 
    &gt; interfere with the triple<br>
    {x is odd} &lt; x := x + 5 &gt; {x is even}.</li>
  <li> Using the technique of weakened assertions, prove that {x = 1}
    S {x = 7} is a theorem, where S is <sr>co &lt; x := x+1&gt;
    &#8214; &lt; x := x+2&gt; &#8214; &lt; x := x+3&gt; oc</sr></li>

</ol>



<h2>References</h2>

<ol>

  <li>Gregory R. Andrews, <i>Concurrent Programming: Principles and
      Practice</i>, Benjamin/Cummings, 1991.  Chapters 1 and 2:
      Required Reading.

  <li>
    Mark Batty, Scott Owens, Susmit Sarkar, Peter Sewell, and Tjark
    Weber, Mathematizing C++ Concurrency, ACM POPL 2011.  Recommended
    Reading.
</ol>


<hr size=1>

<a href="http://www.cs.wright.edu/~pmateti/copyright.html">
  Copyright &copy;</a> 2012
<a href="mailto:pmateti@wright.edu?subject=CEG7370: Distr Comp">
  pmateti@wright.edu</a>

</body>
</html>
