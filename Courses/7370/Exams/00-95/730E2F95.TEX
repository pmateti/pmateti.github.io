\documentstyle[12pt]{article}
\def\CSP{{\sc csp}}
\def\RPC{{\sc rpc}}
\def\SR{{\sc sr}}
\def\fat{\framebox[1mm]{\rule{0mm}{2mm}}}
\def\co{{\bf co}}
\def\oc{{\bf oc}}
\def\pa{{$\parallel$}}
\def\lb{$\langle$}
\def\rb{$\rangle$}
\def\ra{$\rightarrow$}
\def\await{{\bf await}}
\def\zand{\wedge}\def\zor{\vee}	\def\znot{\neg}

\parindent=0pt
\begin{document}


{\bf CEG 
\large \bf 730 Distributed Computing Principles\\[5pt]
\large Final Exam\\[10pt]
Nov 27, 1995 \quad 100 points max \quad 115 minutes\\
}
\bigskip
{Mateti,  Fall Quarter 1995, Wright State U}\\[-5pt]
\hrule

\begin{enumerate}

\item (10*5 points)
Explain/Discuss, in a few lines, the (degree of) truth or falsity of
the following statements.

\begin{enumerate}
\item A {\em critical assertion} is one without which a program will abort.

\item Two processes are {\em interference-free} if they mind their
own business.

\item A {\em safety} property states that nothing ``bad'' will ever happen,
whereas a {\em liveness} property states that something ``good'' will
happen in the next minute.

\item
A typical machine (node) in a distributed system can run several
concurrent processes.  Each of these processes must maintain its own
logical clock in order to correctly deal with the {\em happened
before} relation.

\item
In the Andrews' distributed semaphore implementation of our textbook
that we discussed, there are numerous {\sc ack} messages being sent.
Most of these are unnecessary.

\item Marshalling in \RPC\ is no more than a tight-packing
of the bytes of the input arguments or resulting values.

\item
Every client/server program is based on \RPC\ mechanism.

\item
The detection of termination of distributed processes is nontrivial
because no single process is in possession of the combined states.

\item
In \SR, when invoking an operation implemented by a {\tt proc} through
a {\tt send} the effect is that of a dynamic process creation.

\item
Distributed systems out-number parallel systems by at least a factor
of 10 in this year of 1995.
\end{enumerate}

\item (25 points)
Develop an implementation of general semaphores using only binary
semaphores using the technique of passing the baton.  Show all
the work, including the invariants.

\item (25 points)  [This is a repeat of Problem 3 from the Mid Term.
But this time, you need to do it in Linda.]  
Write a Linda program that does the following.
\parskip=0pt
Your program has two arrays\\

{\tt int a[m], b[n];}\\

already initialized so that they are sorted from low index to high
index.  You then loaded the tuplespace by\\

{\tt
out("m", m); out("n", n);\par
for (i=0; i < m; i++) out("a", i, a[i]);\par
for (i=0; i < n; i++) out("b", i, b[i]);\\
}

Your program then \verb|eval|-led four processes (i.e., a total of
five processes including the main).  These cause a rearrangement of
the tuples so that when the main process inputs the tuples back into
the $a[], b[]$ arrays as in\\

{\tt
for (i=0; i < m; i++) in("newa", i, a[i]);\par
for (i=0; i < n; i++) in("newb", i, b[i]);\\
}

the values are such that no element of $a$ is greater than any element
of $b$.  Explain the main ideas of your program.  Use the
four processes productively.

\end{enumerate}
\end{document}
