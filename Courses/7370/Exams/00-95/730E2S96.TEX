\documentstyle[12pt]{article}
\def\fat{\framebox[1mm]{\rule{0mm}{2mm}}}
\def\CSP{{\sc csp}}
\def\RPC{{\sc rpc}}
\def\SR{{\sc sr}}
\def\co{{\bf co}}
\def\oc{{\bf oc}}
\def\zand{\wedge}\def\zor{\vee}	\def\znot{\neg}
\def\ellipsis{\ldots}
\def\pbar{\parallel}
\def\lb{\langle}
\def\rb{\rangle}
\def\ra{\rightarrow}
\def\await{{\bf await}}
%\textheight=8.3in
\parindent=0pt
\pagestyle{empty}
\begin{document}


{\bf CEG 
\large \bf 730 Distributed Computing Principles\\[5pt]
\large Final Exam\\[10pt]
June 6, 1996 \quad 100 points max \quad 120 minutes\\
}
\bigskip
{Mateti,  Spring Quarter 1996, Wright State U}\\[-5pt]
\hrule

\begin{enumerate}

\item (8*5 points)
Explain/Discuss/Dispute/Answer, in a few lines, the following.


\begin{enumerate}
\item ``The book {\sl Concurrent Programming} by Andrews improves
with each reading.''  Explain if this is a safety, or liveness
property, or perhaps neither.

\item
Explain what the possible values of $x$ are at the end of the following.

\[{\bf var}  x := 0;\quad
\co\ \lb x := x + 2 \rb
\pbar \lb x := x + 2 \rb
\pbar\lb x := x + 2 \rb \ \oc\]


\item
Explain the inference rule 2.11, page 67, of Andrews book reproduced
below.
\begin{quote}
\begin{centering}
\{$P_i\} S_i \{Q_i\}$ are interference-free theorems, $1 \leq i \leq
n$\\[-8pt]
~\hrulefill\\[-4pt]
$\{P_1 \zand \ellipsis \zand P_n\}$
\co\quad $S_1 \pbar \ellipsis \pbar S_n$ \quad\oc
$\{Q_1 \zand \ellipsis \zand Q_n\}$\par
\end{centering}
\end{quote}

\item Discuss the semantics of the semicolon operator as in {\tt S1 ;
S2 }.

\item
\RPC\ cannot be used for peer-to-peer distributed computing.


\item
Given asynchronous message passing primitives, called {\tt asend()}
and {\tt arecv()}, build the synchronous message passing primitives
called {\tt ssend()} and {\tt srecv()}.


\item
There is no way to implement a ``strong'' semaphore in Linda.

\item Token-passing algorithms were discussed under the heading 
of ``asynchronous message passing.''  Does token-passing make sense
under synchronous message passing?  Why, or why not?


\end{enumerate}

\item (2*10 points)
(i) Why is termination detection a nontrivial problem in distributed
systems?  (ii) Describe a token-passing distributed termination
detection algorithm.  Do not assume that the process graph is a tree.
(It is possible to answer in ten-or-so lines each, and yet score
fully.)

\item (10 points)
There are two integer arrays $a[1..m]$ and $b[1..n]$.  We wish to
exchange the odd integers of $a$ with the even integers of $b$, so
that at the end $a$ has as many even integers as possible.  Obviously,
this exchange is limited by the possibly different values of $m$ and
$n$, and is dependent on how many odd numbers there are in
$a[\ellipsis]$ versus the even numbers in $b[\ellipsis]$.

Develop a solution using \CSP.  Maximize concurrency.  Assume that
process $A$ owns $a$, and process $B$ owns $b$.  There must not be any
shared variables whatsoever.

\item (5+10 points)
Using C-Linda, compute the height of a binary tree. (a) Describe how
the binary tree is represented in the tuple space.  (b) Using as many
processes as you wish, present the algorithm, with full explanations,
assuming that the space is preloaded as in (a).  We expect the tuple
space to be empty at the end of the algorithm.



\item (15 points)
The figure below depicts the pointer-based data structures referred in
the next sentence.  Produce the linearized (i.e., marshalled) result,
as discussed in class, for the following remote procedure call {\tt
foobar(...)}:\\

\begin{minipage}[c]{1.75in}
\begin{verbatim}
struct list {
  int elem;
  struct list *next
};
struct graph {
  int elem;
  struct list  *next;
  struct graph *left;
  struct graph *right;
};
\end{verbatim}
\end{minipage}
\quad
\begin{minipage}[c]{1.5in}
\begin{verbatim}
foobar(
  IN  list * a,
  OUT list * b,
  IN  list * c,
  IN  int    d,
  OUT int    e,
  IN  graph* g
 )
\end{verbatim}
\end{minipage}
\begin{minipage}[c]{2.5in}
\setlength{\unitlength}{0.01in}%
\begin{picture}(265,199)(140,600)
\thicklines
\put(267,785){\circle{28}}
\put(232,715){\circle{28}}
\put(296,716){\circle{28}}
\put(266,656){\circle{28}}
\put(168,785){\circle{28}}
\put(167,650){\circle{28}}
\put(167,711){\circle{28}}
\put(165,770){\vector( 0,-1){ 40}}
\put(165,700){\vector( 0,-1){ 35}}
\put(250,785){\vector(-1, 0){ 65}}
\put(215,715){\vector(-1, 0){ 35}}
\put(235,700){\vector( 1,-2){ 18}}
\put(290,705){\vector(-1,-3){ 13.500}}
\put(260,775){\vector(-1,-2){ 23}}
\put(275,770){\vector( 1,-2){ 20}}
\put(250,650){\vector(-1, 0){ 65}}
\put(260,640){\line(-1,-2){ 10}}
\put(165,635){\line( 0,-1){ 15}}
\put(301,701){\line( 2,-3){ 10}}
\put(270,645){\line( 1,-2){ 10}}
\put(224,701){\line(-2,-3){ 10}}
\put(280,715){\line(-1, 0){ 10}}
\put(265,785){1}
\put(230,715){2}
\put(295,710){3}
\put(265,655){4}
\put(165,785){5}
\put(165,710){6}
\put(165,650){7}
\put(160,600){nil}
\put(240,605){nil}
\put(280,605){nil}
\put(310,670){nil}
\put(210,670){nil}
\put(140,785){a}
\put(140,710){b}
\put(140,650){c}
\put(290,790){g}
\put(260,720){nil}

\put(130,815){d}\put(145,815){1234}\put(145,810){\framebox(40,20){}}
\put(225,815){e}\put(240,815){3006}\put(240,810){\framebox(40,20){}}

\end{picture}
\end{minipage}
\end{enumerate}
\end{document}
