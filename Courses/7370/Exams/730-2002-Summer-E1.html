<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>CEG730 Distributed Computing Midterm</title>
</head>

<body bgcolor="#FFFFFF">

<table cellSpacing="10" cellPadding="10" width="100%" border="0" height="125">
  <tr>
    <td width="33%" height="95"><a href="http://www.wright.edu/" 
    target="_blank"><img src="../../../../pmatetiWeb/images/wsu-logo-xsm.gif" 
    border="0" width="150" height="66"></a><br>
    <a href="http://www.cs.wright.edu/">College of Engineering &amp; CS</a><br>
    <a href="http://www.wright.edu/">Wright State University</a><br>
    <a href="http://www.dayton.net/dayton/">Dayton,</a>
    <a href="http://www.state.oh.us/">Ohio</a> 45435-0001</td>
    <td vAlign="top" width="67%" height="95">
    <h2>CEG 730 Distributed Computing Principles</h2>
    <h4>Summer 2002//Mid Term Exam//75 minutes//100 points</h4>
    <p><a href="http://www.cs.wright.edu/~pmateti" target="_blank"><b>Prabhaker 
    Mateti</b></a> </p>
    <p>This is a closed book, closed notes exam. Do not give or take<br>
    help during the exam.</td>
  </tr>
</table>
<ol>
  <li>
   (5*5 points) The following statements may or may not be (fully or partially) 
   valid.&nbsp; <i>First</i>, explain the technical terms occurring in the 
   statement.&nbsp; <i>Then</i>, explain/ discuss/ dispute the statement.&nbsp; 
   It is <i>possible</i> to write no more than, say, ten, sentences each, and 
   yet receive full score.
   <ol type="a">
     <li>
      There is no difference between safety and liveness properties.
     <li>
      The difference between asynchronous and synchronous message passing is 
      trivial.
     <li>
      <code>wp(i := 7,&nbsp; i == 8 or i == 7) == true</code>.<li>
      Marshalling in RPC is no more than a tight-packing of the bytes of the 
      input arguments or resulting values.<li>
      In the context of RPC, a procedure designed to be used remotely <i>can</i> 
      use global variables to communicate with the caller.
   </ol>
  <li>
   (35 points) Consider the following as an await-statement based model of the 
   classic Dining Philosophers problem. The expression <tt>i + 1</tt> is modulo 
   5, and += is normal increment by 1. The <tt>up</tt> and <tt>dn</tt> (down) 
   refer to whether the philosopher picked the fork up or put the fork down.
   <pre>   
   var up[0..4], dn[0..4] initially all 0;
   philosopher[i: 0..4]::
     do true -&gt;
   	think
   	&lt;await up[i] == dn[i] --&gt; up[i] += 1&gt;
   	&lt;await up[i+1] == dn[i+1] --&gt; up[i+1] += 1&gt;
   	eat
   	&lt;dn[i] += 1&gt;
   	&lt;dn[i+1] += 1&gt;
     od
   </pre>
   <ol type="a">
     <li>
      (20 points) Using the Pass-the-Baton technique systematically convert it 
      to an equivalent algorithm using semaphores only. For now, disregard if 
      the above is a ``solution'' or not.
     <li>
      (10 points) Is this a ``solution'' to the Dining Philosophers problem? If 
      so, explain. If not so, fix it at the await-statement level .
     <li>
      (5 points) Is this ``solution'' free from startvation? Explain your 
      answers fully. A simple yes/no will not do.</ol>
  <li>
   (40 points) The solution given for <i>
   <it>Recursive Data Representation: Small Set of Integers</it></i> of Hoare's 
   CSP paper is reproduced below. Extend the solution to respond to a command
   <tt>removeMin()</tt> that removes the least member of the set, if non-empty, 
   and does nothing if the set is empty. Explain your solution. Annotate your 
   algorithm and include a convincing argument that the algorithms is correct.
   <pre>   S(i: 1 .. 100) ::
   	*[   n: integer; S(i-1)?has(n) --&gt; S(0)!false
   	[]   n: integer; S(i-1)?insert(n) --&gt;  
   		*[ m:   integer; S(i-1)?has(m) --&gt;  
   			[   m &lt;=  n --&gt; S(0)!(m = n)
   			[]  m &gt;   n --&gt; S(i+1)!has(m)
   			] 
      		[] m: integer; S(i-1)?insert(m) --&gt;  
   			[  m &lt; n --&gt; S(i+1)!insert(n); n := m
   			[] m = n --&gt;  skip
   			[] m &gt; n --&gt; S(i+1)!insert(m)
   	]  	]	] </pre>
</ol>

</body>

</html>
