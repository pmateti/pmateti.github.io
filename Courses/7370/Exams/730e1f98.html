<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>CEG730 Distributed Computing Midterm Fall 1998</title>
</head>

<body bgcolor="#FFFFFF">

<p>&nbsp;</p>

<h1>CEG 730 Distributed Computing Principles</h1>

<h2>Mid Term Exam</h2>

<h3>Oct 21, 1998 100 points max 75 minutes</h3>

<h3>Mateti, Fall Quarter 1992, Wright State U</h3>

<p>&nbsp;</p>

<pre>\item (5*5 points)
Explain, in a few lines, the truth or falsity of the following
statements.</pre>

<pre>\begin{enumerate}
\item
Every distributed system must also be a concurrent system.</pre>

<pre>\item
There is no difference between safety and liveness properties.</pre>

<pre>\item
The difference between asynchronous and synchronous message
passing is trivial.</pre>

<pre>\item
We need only have one clock per node in order to correctly compute a
happened-before relation.</pre>

<pre>\item Marshalling in \RPC\ is no more than a tight-packing
of the bytes of the input arguments or resulting values.</pre>

<pre>\end{enumerate}</pre>

<pre>\item (30 points)
We have a \CSP\ process {\tt C} that outputs an unending stream of
non-negative numbers to a process named, say, {\tt X}.  We want {\tt
X} to be able to receive requests of the form {\tt X!nthmin(n)} from a
user process {\tt U} and respond with {\tt U!x}, where $x$ is the
$n$-th smallest number it has seen so far from {\tt C}.  If {\tt X}
has seen fewer than $n$ numbers so far, or if $n$ is greater than 10,
or less than 1, the value of $x$ to use is -1.  Write the process {\tt
X} in \CSP.  Maximize concurrency.  Process {\tt C} must not suffer
delays.</pre>

<pre>\item (20 points)
Describe a token-passing distributed termination algorithm.  Do not
assume that the process graph is a tree.
</pre>

<pre>\item (10+15 points)  Udding's solution to the mutual exclusion problem
is reproduced below.  (a) Explain the purpose of each of the
semaphores, using invariants. (b) In the Concluding remarks section,
the author comments ``In this program as in previous programs that
implement semaphores, the order of two V-operations, viz., {\tt V(eu)}
and {\tt V(qu)}, turns out to be crucial.''  There are three
occurrences of {\tt V(eu)}.  Which one is he referring to?  Explain
what would happen if we exchange {\tt V(eu)} with {\tt V(qu)}.</pre>

<pre>\begin{verbatim}
 1 P(eu); ne := ne+1; V(eu);
 2 P(qu); P(eu);	    
 3	nm := nm+1;	    
 4	ne := ne-1;	    
 5	if ne &gt; 0 --&gt; V(eu) 
 6	[] ne = 0 --&gt; V(mu) 
 7	fi;		    
 8 V(qu);		    
 9 P(mu); nm := nm-1;	    
10	&lt;cs &gt;		    
11	if nm &gt; 0 --&gt;  V(mu)
12	[] nm = 0 --&gt;  V(eu)
13	fi		    
\end{verbatim}</pre>

<pre>\end{enumerate}
\end{document}</pre>
</body>
</html>
