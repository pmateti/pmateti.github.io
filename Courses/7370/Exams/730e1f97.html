<HTML>

<HEAD>

   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">

   <META NAME="GENERATOR" CONTENT="Mozilla/4.03 [en] (X11; I; Linux 2.0.30 i586) [Netscape]">

   <TITLE>CEG730 Midterm Fall 1997</TITLE>

</HEAD>

<BODY>

<B><FONT COLOR="#3333FF">(This is a mechanically

converted .html file from .tex using latex2html.&nbsp; For any</FONT></B>

<BR><B><FONT COLOR="#3333FF">clarifications, see the corresponding files

in gamma:/usr/local/lib/Languages/730/)</FONT></B>



<P><B><FONT SIZE=+3>CEG 730 Distributed Computing Principles</FONT></B>



<P><B><FONT SIZE=+2>Mid Term Exam</FONT></B>



<P><B><FONT SIZE=+2>Oct 1997&nbsp;&nbsp; 100 points max&nbsp;&nbsp; 75

minutes</FONT></B>

<BR>&nbsp;

<BR>Mateti, Fall Quarter 1997, Wright State U

<BR>

<HR>

<DL COMPACT>

<DT>

1.</DT>



<DD>

(6*5 points) Explain/Discuss/Dispute /Answer, in a <I>few</I> lines, the

following.</DD>



<DL COMPACT>

<DT>

(a)</DT>



<DD>

Discuss the semantics of the fat-bar operator as in <TT>S1 S2 </TT>.</DD>



<DT>

(b)</DT>



<DD>

The little-endian-ness of a machine has no relevance to RPC.</DD>



<DT>

(c)</DT>



<DD>

What does <TT>svc_run()</TT> do? Why does it not ``return''?</DD>



<DT>

(d)</DT>



<DD>

Explain what <I>dispatching</I> is, in the context of RPC.</DD>



<DT>

(e)</DT>



<DD>

If a client and server happen to reside on the same machine the results

will be unpredictably erroneous.</DD>



<DT>

(f)</DT>



<DD>

``Every philosopher will eventually get hungry.'' Explain if this is a

safety, or liveness property, or perhaps neither.</DD>

</DL>



<DT>

2.</DT>



<DD>

(10+5+10 points)</DD>



<DL COMPACT>

<DT>

(a)</DT>



<DD>

Explain the difference(s) in meaning of the notation versus <I>wp</I>(<I>S</I>,

<I>Q</I>).</DD>



<DT>

(b)</DT>



<DD>

Explain the <B>Concurrency Rule</B>, page 67, inference rule 2.11, of Andrew's

book reproduced below.</DD>



<DD>

\begin{centering}</DD>



<DL COMPACT>$P_i S_i \{Q_i\}$ are interference-free theorems, $1 \leq i

\leq n$\\[-8pt]

<BR>-------------------------------------------------

<BR>$\{P_1 \zand \ldots \zand P_n\}$

<BR>\quad\co\quad $S_1 \parallel \ldots \parallel S_n$ \quad\oc\quad

<BR>$\{Q_1 \zand \ldots \zand Q_n\}$\par

<BR>\end{centering}</DL>



<CENTER>&nbsp;</CENTER>



<DT>

(c)</DT>



<DD>

Consider the following program segment:</DD>



<DD>

\begin{tabbing}</DD>



<DL COMPACT>\co\= \lb \await0\= $x \geq 3$ \=\ra0\= $x := x - 3$ \rb\kill

<BR>\co\> \lb \await \> $x \geq 3$ \>\ra \>$x := x - 3$ \rb\\

<BR>\pa\> \lb \await \> $x \geq 2$ \>\ra \>$x := x - 2$ \rb\\

<BR>\pa\> \lb \await \> $x = 1$ \>\ra \>$x := x + 5$ \rb\\

<BR>\oc

<BR>\end{tabbing}</DL>

Let <I>P</I> be a predicate that characterizes the weakest deadloc-free

precondition for the program, i.e., the largest set of states such that,

if the program is begun in a state satisfying <I>P</I>, then it will terminate

if scheduling is weakly-fair. Determine <I>P</I>. Explain your answer.

<BR>&nbsp;</DL>



<DT>

3.</DT>



<DD>

(5*5 points) The solutions by Udding and Morris to the starvation-free

mutual exclusion problem are reproduced below.</DD>



<DL COMPACT>

<DT>

(a)</DT>



<DD>

State the weak semaphore assumption.</DD>



<DT>

(b)</DT>



<DD>

What are the implications of this assumption with respect to the code fragment

<TT>V(s); P(s)</TT> ?</DD>



<DT>

(c)</DT>



<DD>

What are the initial values of the six semaphores below?</DD>



<DT>

(d)</DT>



<DD>

Must each of the three semaphores in each solution satisfy this assumption?</DD>



<DT>

(e)</DT>



<DD>

Is the functionality/purpose of the <TT>q</TT>-semaphores the same?</DD>

</DL>



<PRE>Udding's solution&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | Morris' solution



&nbsp;1 P(eu); ne := ne+1; V(eu);&nbsp;&nbsp;&nbsp; | P(em); ne := ne+1; V(em);

&nbsp;2 P(qu); P(eu);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | P(qm);

&nbsp;3&nbsp; nm := nm+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; nm := nm+1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

&nbsp;4&nbsp; ne := ne-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; P(em); ne := ne-1;

&nbsp;5&nbsp; if ne > 0 --> V(eu)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; if ne > 0 --> V(em);V(qm)

&nbsp;6&nbsp; [] ne = 0 --> V(mu)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; [] ne = 0 --> V(em);V(mm)

&nbsp;7&nbsp; fi;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; fi;

&nbsp;8 V(qu);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |

&nbsp;9 P(mu); nm := nm-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | P(mm); nm := nm-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

10&nbsp; &lt;cs >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; &lt;cs >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

11&nbsp; if nm > 0 -->&nbsp; V(mu)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; if nm > 0 -->&nbsp; V(mm)&nbsp;

12&nbsp; [] nm = 0 -->&nbsp; V(eu)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; [] nm = 0 -->&nbsp; V(qm)&nbsp;

13&nbsp; fi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; fi</PRE>



<DT>

4.</DT>



<DD>

(20 points) Process <I>A</I> has an array <I>a</I> of 1..<I>m</I> integers

and <I>B</I> has an array <I>b</I> of 1..<I>n</I> integers. The two processes

are allowed to send/receive only one integer at a time. Develop a CSP algorithm

for these processes so that at the end <I>a</I>[1] is the smallest of all

elements of <I>a</I> and <I>b</I>. While elements may have got shuffled,

at the end the two arrays together must have the same bag of elements that

they did at the beginning. Do not assume that the <I>m</I>+<I>n</I> integers

are distinct. Do not assume that the arrays <I>a</I> and <I>b</I> were

sorted initially. Maximize concurrency. Use more processes if you wish.</DD>

</DL>



<HR>

<ADDRESS>

pmateti@cs.wright.edu</ADDRESS>



</BODY>

</HTML>

